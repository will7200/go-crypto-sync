/*
 * Binance SPOT Public API
 *
 * The swagger file of Binance Public API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binance

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

type MarginApi interface {

	/*
	 * SapiV1MarginAccountGet Query Margin Account Details (USER_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginAccountGetRequest
	 */
	SapiV1MarginAccountGet(ctx _context.Context) ApiSapiV1MarginAccountGetRequest

	/*
	 * SapiV1MarginAccountGetExecute executes the request
	 * @return InlineResponse20012
	 */
	SapiV1MarginAccountGetExecute(r ApiSapiV1MarginAccountGetRequest) (InlineResponse20012, *_nethttp.Response, error)

	/*
	 * SapiV1MarginAllAssetsGet Get All Margin Assets (MARKET_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginAllAssetsGetRequest
	 */
	SapiV1MarginAllAssetsGet(ctx _context.Context) ApiSapiV1MarginAllAssetsGetRequest

	/*
	 * SapiV1MarginAllAssetsGetExecute executes the request
	 * @return []InlineResponse2008
	 */
	SapiV1MarginAllAssetsGetExecute(r ApiSapiV1MarginAllAssetsGetRequest) ([]InlineResponse2008, *_nethttp.Response, error)

	/*
			 * SapiV1MarginAllOrdersGet Query Margin Account's All Order (USER_DATA)
			 * - If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
		- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginAllOrdersGetRequest
	*/
	SapiV1MarginAllOrdersGet(ctx _context.Context) ApiSapiV1MarginAllOrdersGetRequest

	/*
	 * SapiV1MarginAllOrdersGetExecute executes the request
	 * @return []MarginOrderDetail
	 */
	SapiV1MarginAllOrdersGetExecute(r ApiSapiV1MarginAllOrdersGetRequest) ([]MarginOrderDetail, *_nethttp.Response, error)

	/*
	 * SapiV1MarginAllPairsGet Get All Margin Pairs (MARKET_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginAllPairsGetRequest
	 */
	SapiV1MarginAllPairsGet(ctx _context.Context) ApiSapiV1MarginAllPairsGetRequest

	/*
	 * SapiV1MarginAllPairsGetExecute executes the request
	 * @return []InlineResponse2009
	 */
	SapiV1MarginAllPairsGetExecute(r ApiSapiV1MarginAllPairsGetRequest) ([]InlineResponse2009, *_nethttp.Response, error)

	/*
	 * SapiV1MarginAssetGet Query Margin Asset (MARKET_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginAssetGetRequest
	 */
	SapiV1MarginAssetGet(ctx _context.Context) ApiSapiV1MarginAssetGetRequest

	/*
	 * SapiV1MarginAssetGetExecute executes the request
	 * @return InlineResponse2006
	 */
	SapiV1MarginAssetGetExecute(r ApiSapiV1MarginAssetGetRequest) (InlineResponse2006, *_nethttp.Response, error)

	/*
	 * SapiV1MarginForceLiquidationRecGet Get Force Liquidation Record (USER_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginForceLiquidationRecGetRequest
	 */
	SapiV1MarginForceLiquidationRecGet(ctx _context.Context) ApiSapiV1MarginForceLiquidationRecGetRequest

	/*
	 * SapiV1MarginForceLiquidationRecGetExecute executes the request
	 * @return map[string]interface{}
	 */
	SapiV1MarginForceLiquidationRecGetExecute(r ApiSapiV1MarginForceLiquidationRecGetRequest) (map[string]interface{}, *_nethttp.Response, error)

	/*
	 * SapiV1MarginInterestHistoryGet Query Interest History (MARKET_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginInterestHistoryGetRequest
	 */
	SapiV1MarginInterestHistoryGet(ctx _context.Context) ApiSapiV1MarginInterestHistoryGetRequest

	/*
	 * SapiV1MarginInterestHistoryGetExecute executes the request
	 * @return InlineResponse20011
	 */
	SapiV1MarginInterestHistoryGetExecute(r ApiSapiV1MarginInterestHistoryGetRequest) (InlineResponse20011, *_nethttp.Response, error)

	/*
			 * SapiV1MarginLoanGet Query Load Record (USER_DATA)
			 * `txId` or `startTime` must be sent. txId takes precedence.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginLoanGetRequest
	*/
	SapiV1MarginLoanGet(ctx _context.Context) ApiSapiV1MarginLoanGetRequest

	/*
	 * SapiV1MarginLoanGetExecute executes the request
	 * @return map[string]interface{}
	 */
	SapiV1MarginLoanGetExecute(r ApiSapiV1MarginLoanGetRequest) (map[string]interface{}, *_nethttp.Response, error)

	/*
			 * SapiV1MarginLoanPost Margin Account Borrow (MARGIN)
			 * Apply for a loan.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginLoanPostRequest
	*/
	SapiV1MarginLoanPost(ctx _context.Context) ApiSapiV1MarginLoanPostRequest

	/*
	 * SapiV1MarginLoanPostExecute executes the request
	 * @return Transaction
	 */
	SapiV1MarginLoanPostExecute(r ApiSapiV1MarginLoanPostRequest) (Transaction, *_nethttp.Response, error)

	/*
	 * SapiV1MarginMaxBorrowableGet Query Max Borrow (USER_DATA)
	 * Weight: 5
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginMaxBorrowableGetRequest
	 */
	SapiV1MarginMaxBorrowableGet(ctx _context.Context) ApiSapiV1MarginMaxBorrowableGetRequest

	/*
	 * SapiV1MarginMaxBorrowableGetExecute executes the request
	 * @return map[string]interface{}
	 */
	SapiV1MarginMaxBorrowableGetExecute(r ApiSapiV1MarginMaxBorrowableGetRequest) (map[string]interface{}, *_nethttp.Response, error)

	/*
	 * SapiV1MarginMaxTransferableGet Query Max Transfer-Out Amount (USER_DATA)
	 * Weight: 5
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginMaxTransferableGetRequest
	 */
	SapiV1MarginMaxTransferableGet(ctx _context.Context) ApiSapiV1MarginMaxTransferableGetRequest

	/*
	 * SapiV1MarginMaxTransferableGetExecute executes the request
	 * @return map[string]interface{}
	 */
	SapiV1MarginMaxTransferableGetExecute(r ApiSapiV1MarginMaxTransferableGetRequest) (map[string]interface{}, *_nethttp.Response, error)

	/*
	 * SapiV1MarginMyTradesGet If fromId is set, it will get orders >= that fromId. Otherwise most recent orders are returned.
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginMyTradesGetRequest
	 */
	SapiV1MarginMyTradesGet(ctx _context.Context) ApiSapiV1MarginMyTradesGetRequest

	/*
	 * SapiV1MarginMyTradesGetExecute executes the request
	 * @return []MarginTrade
	 */
	SapiV1MarginMyTradesGetExecute(r ApiSapiV1MarginMyTradesGetRequest) ([]MarginTrade, *_nethttp.Response, error)

	/*
			 * SapiV1MarginOpenOrdersGet Query Margin Account's Open Order (USER_DATA)
			 * - If the symbol is not sent, orders for all symbols will be returned in an array.
		- When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginOpenOrdersGetRequest
	*/
	SapiV1MarginOpenOrdersGet(ctx _context.Context) ApiSapiV1MarginOpenOrdersGetRequest

	/*
	 * SapiV1MarginOpenOrdersGetExecute executes the request
	 * @return []MarginOrderDetail
	 */
	SapiV1MarginOpenOrdersGetExecute(r ApiSapiV1MarginOpenOrdersGetRequest) ([]MarginOrderDetail, *_nethttp.Response, error)

	/*
			 * SapiV1MarginOrderDelete Margin Account Cancel Order (TRADE)
			 * Cancel an active order for margin account.

		Either orderId or origClientOrderId must be sent.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginOrderDeleteRequest
	*/
	SapiV1MarginOrderDelete(ctx _context.Context) ApiSapiV1MarginOrderDeleteRequest

	/*
	 * SapiV1MarginOrderDeleteExecute executes the request
	 * @return MarginOrder
	 */
	SapiV1MarginOrderDeleteExecute(r ApiSapiV1MarginOrderDeleteRequest) (MarginOrder, *_nethttp.Response, error)

	/*
			 * SapiV1MarginOrderGet Query Margin Account's Order (MARKET_DATA)
			 * - Either `orderId` or `origClientOrderId` must be sent.
		- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginOrderGetRequest
	*/
	SapiV1MarginOrderGet(ctx _context.Context) ApiSapiV1MarginOrderGetRequest

	/*
	 * SapiV1MarginOrderGetExecute executes the request
	 * @return MarginOrderDetail
	 */
	SapiV1MarginOrderGetExecute(r ApiSapiV1MarginOrderGetRequest) (MarginOrderDetail, *_nethttp.Response, error)

	/*
			 * SapiV1MarginOrderPost Margin Account New Order (TRADE)
			 * Post a new order for margin account.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginOrderPostRequest
	*/
	SapiV1MarginOrderPost(ctx _context.Context) ApiSapiV1MarginOrderPostRequest

	/*
	 * SapiV1MarginOrderPostExecute executes the request
	 * @return MarginOrderResponse
	 */
	SapiV1MarginOrderPostExecute(r ApiSapiV1MarginOrderPostRequest) (MarginOrderResponse, *_nethttp.Response, error)

	/*
	 * SapiV1MarginPairGet Query Margin Pair (MARKET_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginPairGetRequest
	 */
	SapiV1MarginPairGet(ctx _context.Context) ApiSapiV1MarginPairGetRequest

	/*
	 * SapiV1MarginPairGetExecute executes the request
	 * @return InlineResponse2007
	 */
	SapiV1MarginPairGetExecute(r ApiSapiV1MarginPairGetRequest) (InlineResponse2007, *_nethttp.Response, error)

	/*
	 * SapiV1MarginPriceIndexGet Query Margin PriceIndex (MARKET_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginPriceIndexGetRequest
	 */
	SapiV1MarginPriceIndexGet(ctx _context.Context) ApiSapiV1MarginPriceIndexGetRequest

	/*
	 * SapiV1MarginPriceIndexGetExecute executes the request
	 * @return InlineResponse20010
	 */
	SapiV1MarginPriceIndexGetExecute(r ApiSapiV1MarginPriceIndexGetRequest) (InlineResponse20010, *_nethttp.Response, error)

	/*
			 * SapiV1MarginRepayGet Query Repay Record (USER_DATA)
			 * `txId` or `startTime` must be sent. txId takes precedence.
		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginRepayGetRequest
	*/
	SapiV1MarginRepayGet(ctx _context.Context) ApiSapiV1MarginRepayGetRequest

	/*
	 * SapiV1MarginRepayGetExecute executes the request
	 * @return InlineResponse2005
	 */
	SapiV1MarginRepayGetExecute(r ApiSapiV1MarginRepayGetRequest) (InlineResponse2005, *_nethttp.Response, error)

	/*
			 * SapiV1MarginRepayPost Margin Account Repay (MARGIN)
			 * Repay loan for margin account.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginRepayPostRequest
	*/
	SapiV1MarginRepayPost(ctx _context.Context) ApiSapiV1MarginRepayPostRequest

	/*
	 * SapiV1MarginRepayPostExecute executes the request
	 * @return Transaction
	 */
	SapiV1MarginRepayPostExecute(r ApiSapiV1MarginRepayPostRequest) (Transaction, *_nethttp.Response, error)

	/*
	 * SapiV1MarginTransferGet Get Transfer History (USER_DATA)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiSapiV1MarginTransferGetRequest
	 */
	SapiV1MarginTransferGet(ctx _context.Context) ApiSapiV1MarginTransferGetRequest

	/*
	 * SapiV1MarginTransferGetExecute executes the request
	 * @return map[string]interface{}
	 */
	SapiV1MarginTransferGetExecute(r ApiSapiV1MarginTransferGetRequest) (map[string]interface{}, *_nethttp.Response, error)

	/*
			 * SapiV1MarginTransferPost Margin Account Transfer (MARGIN)
			 * Execute transfer between spot account and margin account.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1MarginTransferPostRequest
	*/
	SapiV1MarginTransferPost(ctx _context.Context) ApiSapiV1MarginTransferPostRequest

	/*
	 * SapiV1MarginTransferPostExecute executes the request
	 * @return Transaction
	 */
	SapiV1MarginTransferPostExecute(r ApiSapiV1MarginTransferPostRequest) (Transaction, *_nethttp.Response, error)
}

// MarginApiService MarginApi service
type MarginApiService service

type ApiSapiV1MarginAccountGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginAccountGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginAccountGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginAccountGetRequest) Signature(signature string) ApiSapiV1MarginAccountGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginAccountGetRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAccountGetExecute(r)
}

/*
 * SapiV1MarginAccountGet Query Margin Account Details (USER_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginAccountGetRequest
 */
func (a *MarginApiService) SapiV1MarginAccountGet(ctx _context.Context) ApiSapiV1MarginAccountGetRequest {
	return ApiSapiV1MarginAccountGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20012
 */
func (a *MarginApiService) SapiV1MarginAccountGetExecute(r ApiSapiV1MarginAccountGetRequest) (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllAssetsGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
}

func (r ApiSapiV1MarginAllAssetsGetRequest) Execute() ([]InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllAssetsGetExecute(r)
}

/*
 * SapiV1MarginAllAssetsGet Get All Margin Assets (MARKET_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginAllAssetsGetRequest
 */
func (a *MarginApiService) SapiV1MarginAllAssetsGet(ctx _context.Context) ApiSapiV1MarginAllAssetsGetRequest {
	return ApiSapiV1MarginAllAssetsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse2008
 */
func (a *MarginApiService) SapiV1MarginAllAssetsGetExecute(r ApiSapiV1MarginAllAssetsGetRequest) ([]InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllAssetsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allAssets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllOrdersGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
	orderId    *int32
	startTime  *int32
	endTime    *int32
	limit      *int32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginAllOrdersGetRequest) Symbol(symbol string) ApiSapiV1MarginAllOrdersGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) OrderId(orderId int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.orderId = &orderId
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) StartTime(startTime int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) EndTime(endTime int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) Limit(limit int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginAllOrdersGetRequest) Signature(signature string) ApiSapiV1MarginAllOrdersGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginAllOrdersGetRequest) Execute() ([]MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllOrdersGetExecute(r)
}

/*
 * SapiV1MarginAllOrdersGet Query Margin Account's All Order (USER_DATA)
 * - If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginAllOrdersGetRequest
*/
func (a *MarginApiService) SapiV1MarginAllOrdersGet(ctx _context.Context) ApiSapiV1MarginAllOrdersGetRequest {
	return ApiSapiV1MarginAllOrdersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []MarginOrderDetail
 */
func (a *MarginApiService) SapiV1MarginAllOrdersGetExecute(r ApiSapiV1MarginAllOrdersGetRequest) ([]MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllPairsGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
}

func (r ApiSapiV1MarginAllPairsGetRequest) Execute() ([]InlineResponse2009, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllPairsGetExecute(r)
}

/*
 * SapiV1MarginAllPairsGet Get All Margin Pairs (MARKET_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginAllPairsGetRequest
 */
func (a *MarginApiService) SapiV1MarginAllPairsGet(ctx _context.Context) ApiSapiV1MarginAllPairsGetRequest {
	return ApiSapiV1MarginAllPairsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse2009
 */
func (a *MarginApiService) SapiV1MarginAllPairsGetExecute(r ApiSapiV1MarginAllPairsGetRequest) ([]InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllPairsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allPairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAssetGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
}

func (r ApiSapiV1MarginAssetGetRequest) Asset(asset string) ApiSapiV1MarginAssetGetRequest {
	r.asset = &asset
	return r
}

func (r ApiSapiV1MarginAssetGetRequest) Execute() (InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAssetGetExecute(r)
}

/*
 * SapiV1MarginAssetGet Query Margin Asset (MARKET_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginAssetGetRequest
 */
func (a *MarginApiService) SapiV1MarginAssetGet(ctx _context.Context) ApiSapiV1MarginAssetGetRequest {
	return ApiSapiV1MarginAssetGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2006
 */
func (a *MarginApiService) SapiV1MarginAssetGetExecute(r ApiSapiV1MarginAssetGetRequest) (InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAssetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginForceLiquidationRecGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	startTime  *int32
	endTime    *int32
	current    *float32
	size       *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginForceLiquidationRecGetRequest) StartTime(startTime int32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) EndTime(endTime int32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Current(current float32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.current = &current
	return r
}
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Size(size float32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.size = &size
	return r
}
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Signature(signature string) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginForceLiquidationRecGetExecute(r)
}

/*
 * SapiV1MarginForceLiquidationRecGet Get Force Liquidation Record (USER_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginForceLiquidationRecGetRequest
 */
func (a *MarginApiService) SapiV1MarginForceLiquidationRecGet(ctx _context.Context) ApiSapiV1MarginForceLiquidationRecGetRequest {
	return ApiSapiV1MarginForceLiquidationRecGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *MarginApiService) SapiV1MarginForceLiquidationRecGetExecute(r ApiSapiV1MarginForceLiquidationRecGetRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginForceLiquidationRecGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/forceLiquidationRec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginInterestHistoryGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	startTime  *int32
	endTime    *int32
	current    *float32
	size       *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginInterestHistoryGetRequest) Asset(asset string) ApiSapiV1MarginInterestHistoryGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) StartTime(startTime int32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) EndTime(endTime int32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) Current(current float32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.current = &current
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) Size(size float32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.size = &size
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) Signature(signature string) ApiSapiV1MarginInterestHistoryGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginInterestHistoryGetRequest) Execute() (InlineResponse20011, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginInterestHistoryGetExecute(r)
}

/*
 * SapiV1MarginInterestHistoryGet Query Interest History (MARKET_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginInterestHistoryGetRequest
 */
func (a *MarginApiService) SapiV1MarginInterestHistoryGet(ctx _context.Context) ApiSapiV1MarginInterestHistoryGetRequest {
	return ApiSapiV1MarginInterestHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20011
 */
func (a *MarginApiService) SapiV1MarginInterestHistoryGetExecute(r ApiSapiV1MarginInterestHistoryGetRequest) (InlineResponse20011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginInterestHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/interestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginLoanGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	txId       *int32
	startTime  *int32
	endTime    *int32
	current    *float32
	size       *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginLoanGetRequest) Asset(asset string) ApiSapiV1MarginLoanGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) TxId(txId int32) ApiSapiV1MarginLoanGetRequest {
	r.txId = &txId
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) StartTime(startTime int32) ApiSapiV1MarginLoanGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) EndTime(endTime int32) ApiSapiV1MarginLoanGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) Current(current float32) ApiSapiV1MarginLoanGetRequest {
	r.current = &current
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) Size(size float32) ApiSapiV1MarginLoanGetRequest {
	r.size = &size
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginLoanGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginLoanGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginLoanGetRequest) Signature(signature string) ApiSapiV1MarginLoanGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginLoanGetRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginLoanGetExecute(r)
}

/*
 * SapiV1MarginLoanGet Query Load Record (USER_DATA)
 * `txId` or `startTime` must be sent. txId takes precedence.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginLoanGetRequest
*/
func (a *MarginApiService) SapiV1MarginLoanGet(ctx _context.Context) ApiSapiV1MarginLoanGetRequest {
	return ApiSapiV1MarginLoanGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *MarginApiService) SapiV1MarginLoanGetExecute(r ApiSapiV1MarginLoanGetRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginLoanGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.txId != nil {
		localVarQueryParams.Add("txId", parameterToString(*r.txId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginLoanPostRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	amount     *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginLoanPostRequest) Asset(asset string) ApiSapiV1MarginLoanPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginLoanPostRequest) Amount(amount float32) ApiSapiV1MarginLoanPostRequest {
	r.amount = &amount
	return r
}
func (r ApiSapiV1MarginLoanPostRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginLoanPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginLoanPostRequest) Timestamp(timestamp int32) ApiSapiV1MarginLoanPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginLoanPostRequest) Signature(signature string) ApiSapiV1MarginLoanPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginLoanPostRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginLoanPostExecute(r)
}

/*
 * SapiV1MarginLoanPost Margin Account Borrow (MARGIN)
 * Apply for a loan.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginLoanPostRequest
*/
func (a *MarginApiService) SapiV1MarginLoanPost(ctx _context.Context) ApiSapiV1MarginLoanPostRequest {
	return ApiSapiV1MarginLoanPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *MarginApiService) SapiV1MarginLoanPostExecute(r ApiSapiV1MarginLoanPostRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginLoanPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginMaxBorrowableGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginMaxBorrowableGetRequest) Symbol(symbol string) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginMaxBorrowableGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginMaxBorrowableGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginMaxBorrowableGetRequest) Signature(signature string) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginMaxBorrowableGetRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginMaxBorrowableGetExecute(r)
}

/*
 * SapiV1MarginMaxBorrowableGet Query Max Borrow (USER_DATA)
 * Weight: 5
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginMaxBorrowableGetRequest
 */
func (a *MarginApiService) SapiV1MarginMaxBorrowableGet(ctx _context.Context) ApiSapiV1MarginMaxBorrowableGetRequest {
	return ApiSapiV1MarginMaxBorrowableGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *MarginApiService) SapiV1MarginMaxBorrowableGetExecute(r ApiSapiV1MarginMaxBorrowableGetRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginMaxBorrowableGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/maxBorrowable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginMaxTransferableGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginMaxTransferableGetRequest) Symbol(symbol string) ApiSapiV1MarginMaxTransferableGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginMaxTransferableGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginMaxTransferableGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginMaxTransferableGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginMaxTransferableGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginMaxTransferableGetRequest) Signature(signature string) ApiSapiV1MarginMaxTransferableGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginMaxTransferableGetRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginMaxTransferableGetExecute(r)
}

/*
 * SapiV1MarginMaxTransferableGet Query Max Transfer-Out Amount (USER_DATA)
 * Weight: 5
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginMaxTransferableGetRequest
 */
func (a *MarginApiService) SapiV1MarginMaxTransferableGet(ctx _context.Context) ApiSapiV1MarginMaxTransferableGetRequest {
	return ApiSapiV1MarginMaxTransferableGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *MarginApiService) SapiV1MarginMaxTransferableGetExecute(r ApiSapiV1MarginMaxTransferableGetRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginMaxTransferableGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/maxTransferable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginMyTradesGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
	startTime  *int32
	endTime    *int32
	fromId     *int32
	limit      *int32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginMyTradesGetRequest) Symbol(symbol string) ApiSapiV1MarginMyTradesGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) StartTime(startTime int32) ApiSapiV1MarginMyTradesGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) EndTime(endTime int32) ApiSapiV1MarginMyTradesGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) FromId(fromId int32) ApiSapiV1MarginMyTradesGetRequest {
	r.fromId = &fromId
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) Limit(limit int32) ApiSapiV1MarginMyTradesGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginMyTradesGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginMyTradesGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginMyTradesGetRequest) Signature(signature string) ApiSapiV1MarginMyTradesGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginMyTradesGetRequest) Execute() ([]MarginTrade, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginMyTradesGetExecute(r)
}

/*
 * SapiV1MarginMyTradesGet If fromId is set, it will get orders >= that fromId. Otherwise most recent orders are returned.
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginMyTradesGetRequest
 */
func (a *MarginApiService) SapiV1MarginMyTradesGet(ctx _context.Context) ApiSapiV1MarginMyTradesGetRequest {
	return ApiSapiV1MarginMyTradesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []MarginTrade
 */
func (a *MarginApiService) SapiV1MarginMyTradesGetExecute(r ApiSapiV1MarginMyTradesGetRequest) ([]MarginTrade, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginMyTradesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOpenOrdersGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginOpenOrdersGetRequest) Symbol(symbol string) ApiSapiV1MarginOpenOrdersGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginOpenOrdersGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginOpenOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginOpenOrdersGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginOpenOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginOpenOrdersGetRequest) Signature(signature string) ApiSapiV1MarginOpenOrdersGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginOpenOrdersGetRequest) Execute() ([]MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOpenOrdersGetExecute(r)
}

/*
 * SapiV1MarginOpenOrdersGet Query Margin Account's Open Order (USER_DATA)
 * - If the symbol is not sent, orders for all symbols will be returned in an array.
- When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginOpenOrdersGetRequest
*/
func (a *MarginApiService) SapiV1MarginOpenOrdersGet(ctx _context.Context) ApiSapiV1MarginOpenOrdersGetRequest {
	return ApiSapiV1MarginOpenOrdersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []MarginOrderDetail
 */
func (a *MarginApiService) SapiV1MarginOpenOrdersGetExecute(r ApiSapiV1MarginOpenOrdersGetRequest) ([]MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOpenOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderDeleteRequest struct {
	ctx               _context.Context
	ApiService        MarginApi
	symbol            *string
	orderId           *int32
	origClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int32
	timestamp         *int32
	signature         *string
}

func (r ApiSapiV1MarginOrderDeleteRequest) Symbol(symbol string) ApiSapiV1MarginOrderDeleteRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginOrderDeleteRequest) OrderId(orderId int32) ApiSapiV1MarginOrderDeleteRequest {
	r.orderId = &orderId
	return r
}
func (r ApiSapiV1MarginOrderDeleteRequest) OrigClientOrderId(origClientOrderId string) ApiSapiV1MarginOrderDeleteRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
func (r ApiSapiV1MarginOrderDeleteRequest) NewClientOrderId(newClientOrderId string) ApiSapiV1MarginOrderDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
func (r ApiSapiV1MarginOrderDeleteRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginOrderDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginOrderDeleteRequest) Timestamp(timestamp int32) ApiSapiV1MarginOrderDeleteRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginOrderDeleteRequest) Signature(signature string) ApiSapiV1MarginOrderDeleteRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginOrderDeleteRequest) Execute() (MarginOrder, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderDeleteExecute(r)
}

/*
 * SapiV1MarginOrderDelete Margin Account Cancel Order (TRADE)
 * Cancel an active order for margin account.

Either orderId or origClientOrderId must be sent.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginOrderDeleteRequest
*/
func (a *MarginApiService) SapiV1MarginOrderDelete(ctx _context.Context) ApiSapiV1MarginOrderDeleteRequest {
	return ApiSapiV1MarginOrderDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return MarginOrder
 */
func (a *MarginApiService) SapiV1MarginOrderDeleteExecute(r ApiSapiV1MarginOrderDeleteRequest) (MarginOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderGetRequest struct {
	ctx               _context.Context
	ApiService        MarginApi
	symbol            *string
	orderId           *int32
	origClientOrderId *string
	recvWindow        *int32
	timestamp         *int32
	signature         *string
}

func (r ApiSapiV1MarginOrderGetRequest) Symbol(symbol string) ApiSapiV1MarginOrderGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginOrderGetRequest) OrderId(orderId int32) ApiSapiV1MarginOrderGetRequest {
	r.orderId = &orderId
	return r
}
func (r ApiSapiV1MarginOrderGetRequest) OrigClientOrderId(origClientOrderId string) ApiSapiV1MarginOrderGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
func (r ApiSapiV1MarginOrderGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginOrderGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginOrderGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginOrderGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginOrderGetRequest) Signature(signature string) ApiSapiV1MarginOrderGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginOrderGetRequest) Execute() (MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderGetExecute(r)
}

/*
 * SapiV1MarginOrderGet Query Margin Account's Order (MARKET_DATA)
 * - Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginOrderGetRequest
*/
func (a *MarginApiService) SapiV1MarginOrderGet(ctx _context.Context) ApiSapiV1MarginOrderGetRequest {
	return ApiSapiV1MarginOrderGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return MarginOrderDetail
 */
func (a *MarginApiService) SapiV1MarginOrderGetExecute(r ApiSapiV1MarginOrderGetRequest) (MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderPostRequest struct {
	ctx              _context.Context
	ApiService       MarginApi
	symbol           *string
	side             *string
	type_            *string
	quantity         *float32
	price            *float32
	stopPrice        *float32
	newClientOrderId *string
	icebergQty       *float32
	newOrderRespType *string
	sideEffectType   *string
	timeInForce      *string
	recvWindow       *int32
	timestamp        *int32
	signature        *string
}

func (r ApiSapiV1MarginOrderPostRequest) Symbol(symbol string) ApiSapiV1MarginOrderPostRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Side(side string) ApiSapiV1MarginOrderPostRequest {
	r.side = &side
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Type_(type_ string) ApiSapiV1MarginOrderPostRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Quantity(quantity float32) ApiSapiV1MarginOrderPostRequest {
	r.quantity = &quantity
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Price(price float32) ApiSapiV1MarginOrderPostRequest {
	r.price = &price
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) StopPrice(stopPrice float32) ApiSapiV1MarginOrderPostRequest {
	r.stopPrice = &stopPrice
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) NewClientOrderId(newClientOrderId string) ApiSapiV1MarginOrderPostRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) IcebergQty(icebergQty float32) ApiSapiV1MarginOrderPostRequest {
	r.icebergQty = &icebergQty
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) NewOrderRespType(newOrderRespType string) ApiSapiV1MarginOrderPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) SideEffectType(sideEffectType string) ApiSapiV1MarginOrderPostRequest {
	r.sideEffectType = &sideEffectType
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) TimeInForce(timeInForce string) ApiSapiV1MarginOrderPostRequest {
	r.timeInForce = &timeInForce
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginOrderPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Timestamp(timestamp int32) ApiSapiV1MarginOrderPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Signature(signature string) ApiSapiV1MarginOrderPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginOrderPostRequest) Execute() (MarginOrderResponse, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderPostExecute(r)
}

/*
 * SapiV1MarginOrderPost Margin Account New Order (TRADE)
 * Post a new order for margin account.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginOrderPostRequest
*/
func (a *MarginApiService) SapiV1MarginOrderPost(ctx _context.Context) ApiSapiV1MarginOrderPostRequest {
	return ApiSapiV1MarginOrderPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return MarginOrderResponse
 */
func (a *MarginApiService) SapiV1MarginOrderPostExecute(r ApiSapiV1MarginOrderPostRequest) (MarginOrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginPairGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
}

func (r ApiSapiV1MarginPairGetRequest) Symbol(symbol string) ApiSapiV1MarginPairGetRequest {
	r.symbol = &symbol
	return r
}

func (r ApiSapiV1MarginPairGetRequest) Execute() (InlineResponse2007, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginPairGetExecute(r)
}

/*
 * SapiV1MarginPairGet Query Margin Pair (MARKET_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginPairGetRequest
 */
func (a *MarginApiService) SapiV1MarginPairGet(ctx _context.Context) ApiSapiV1MarginPairGetRequest {
	return ApiSapiV1MarginPairGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2007
 */
func (a *MarginApiService) SapiV1MarginPairGetExecute(r ApiSapiV1MarginPairGetRequest) (InlineResponse2007, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginPairGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginPriceIndexGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	symbol     *string
}

func (r ApiSapiV1MarginPriceIndexGetRequest) Symbol(symbol string) ApiSapiV1MarginPriceIndexGetRequest {
	r.symbol = &symbol
	return r
}

func (r ApiSapiV1MarginPriceIndexGetRequest) Execute() (InlineResponse20010, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginPriceIndexGetExecute(r)
}

/*
 * SapiV1MarginPriceIndexGet Query Margin PriceIndex (MARKET_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginPriceIndexGetRequest
 */
func (a *MarginApiService) SapiV1MarginPriceIndexGet(ctx _context.Context) ApiSapiV1MarginPriceIndexGetRequest {
	return ApiSapiV1MarginPriceIndexGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20010
 */
func (a *MarginApiService) SapiV1MarginPriceIndexGetExecute(r ApiSapiV1MarginPriceIndexGetRequest) (InlineResponse20010, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20010
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginPriceIndexGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/priceIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginRepayGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	txId       *int32
	startTime  *int32
	endTime    *int32
	current    *float32
	size       *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginRepayGetRequest) Asset(asset string) ApiSapiV1MarginRepayGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) TxId(txId int32) ApiSapiV1MarginRepayGetRequest {
	r.txId = &txId
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) StartTime(startTime int32) ApiSapiV1MarginRepayGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) EndTime(endTime int32) ApiSapiV1MarginRepayGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) Current(current float32) ApiSapiV1MarginRepayGetRequest {
	r.current = &current
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) Size(size float32) ApiSapiV1MarginRepayGetRequest {
	r.size = &size
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginRepayGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginRepayGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginRepayGetRequest) Signature(signature string) ApiSapiV1MarginRepayGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginRepayGetRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginRepayGetExecute(r)
}

/*
 * SapiV1MarginRepayGet Query Repay Record (USER_DATA)
 * `txId` or `startTime` must be sent. txId takes precedence.
Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginRepayGetRequest
*/
func (a *MarginApiService) SapiV1MarginRepayGet(ctx _context.Context) ApiSapiV1MarginRepayGetRequest {
	return ApiSapiV1MarginRepayGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2005
 */
func (a *MarginApiService) SapiV1MarginRepayGetExecute(r ApiSapiV1MarginRepayGetRequest) (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginRepayGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.txId != nil {
		localVarQueryParams.Add("txId", parameterToString(*r.txId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginRepayPostRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	amount     *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginRepayPostRequest) Asset(asset string) ApiSapiV1MarginRepayPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginRepayPostRequest) Amount(amount float32) ApiSapiV1MarginRepayPostRequest {
	r.amount = &amount
	return r
}
func (r ApiSapiV1MarginRepayPostRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginRepayPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginRepayPostRequest) Timestamp(timestamp int32) ApiSapiV1MarginRepayPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginRepayPostRequest) Signature(signature string) ApiSapiV1MarginRepayPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginRepayPostRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginRepayPostExecute(r)
}

/*
 * SapiV1MarginRepayPost Margin Account Repay (MARGIN)
 * Repay loan for margin account.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginRepayPostRequest
*/
func (a *MarginApiService) SapiV1MarginRepayPost(ctx _context.Context) ApiSapiV1MarginRepayPostRequest {
	return ApiSapiV1MarginRepayPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *MarginApiService) SapiV1MarginRepayPostExecute(r ApiSapiV1MarginRepayPostRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginRepayPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginTransferGetRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	type_      *string
	startTime  *int32
	endTime    *int32
	current    *float32
	size       *float32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginTransferGetRequest) Asset(asset string) ApiSapiV1MarginTransferGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) Type_(type_ string) ApiSapiV1MarginTransferGetRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) StartTime(startTime int32) ApiSapiV1MarginTransferGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) EndTime(endTime int32) ApiSapiV1MarginTransferGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) Current(current float32) ApiSapiV1MarginTransferGetRequest {
	r.current = &current
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) Size(size float32) ApiSapiV1MarginTransferGetRequest {
	r.size = &size
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginTransferGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) Timestamp(timestamp int32) ApiSapiV1MarginTransferGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) Signature(signature string) ApiSapiV1MarginTransferGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginTransferGetRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginTransferGetExecute(r)
}

/*
 * SapiV1MarginTransferGet Get Transfer History (USER_DATA)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginTransferGetRequest
 */
func (a *MarginApiService) SapiV1MarginTransferGet(ctx _context.Context) ApiSapiV1MarginTransferGetRequest {
	return ApiSapiV1MarginTransferGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *MarginApiService) SapiV1MarginTransferGetExecute(r ApiSapiV1MarginTransferGetRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginTransferPostRequest struct {
	ctx        _context.Context
	ApiService MarginApi
	asset      *string
	amount     *float32
	type_      *int32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1MarginTransferPostRequest) Asset(asset string) ApiSapiV1MarginTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginTransferPostRequest) Amount(amount float32) ApiSapiV1MarginTransferPostRequest {
	r.amount = &amount
	return r
}
func (r ApiSapiV1MarginTransferPostRequest) Type_(type_ int32) ApiSapiV1MarginTransferPostRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1MarginTransferPostRequest) RecvWindow(recvWindow int32) ApiSapiV1MarginTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1MarginTransferPostRequest) Timestamp(timestamp int32) ApiSapiV1MarginTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1MarginTransferPostRequest) Signature(signature string) ApiSapiV1MarginTransferPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1MarginTransferPostRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginTransferPostExecute(r)
}

/*
 * SapiV1MarginTransferPost Margin Account Transfer (MARGIN)
 * Execute transfer between spot account and margin account.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1MarginTransferPostRequest
*/
func (a *MarginApiService) SapiV1MarginTransferPost(ctx _context.Context) ApiSapiV1MarginTransferPostRequest {
	return ApiSapiV1MarginTransferPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Transaction
 */
func (a *MarginApiService) SapiV1MarginTransferPostExecute(r ApiSapiV1MarginTransferPostRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
