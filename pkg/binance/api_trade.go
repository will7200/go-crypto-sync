/*
 * Binance SPOT Public API
 *
 * The swagger file of Binance Public API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binance

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

type TradeApi interface {

	/*
			 * ApiV3AccountGet Account Information (USER_DATA)
			 * Get current account information.

		Weight: 5
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3AccountGetRequest
	*/
	ApiV3AccountGet(ctx _context.Context) ApiApiV3AccountGetRequest

	/*
	 * ApiV3AccountGetExecute executes the request
	 * @return Account
	 */
	ApiV3AccountGetExecute(r ApiApiV3AccountGetRequest) (Account, *_nethttp.Response, error)

	/*
			 * ApiV3AllOrderListGet Query all OCO (USER_DATA)
			 * Retrieves all OCO based on provided optional parameters

		Weight: 10
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3AllOrderListGetRequest
	*/
	ApiV3AllOrderListGet(ctx _context.Context) ApiApiV3AllOrderListGetRequest

	/*
	 * ApiV3AllOrderListGetExecute executes the request
	 * @return []OCOOrder
	 */
	ApiV3AllOrderListGetExecute(r ApiApiV3AllOrderListGetRequest) ([]OCOOrder, *_nethttp.Response, error)

	/*
			 * ApiV3AllOrdersGet All Orders (USER_DATA)
			 * Get all account orders; active, canceled, or filled..

		- If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
		- For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.

		Weight: 5
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3AllOrdersGetRequest
	*/
	ApiV3AllOrdersGet(ctx _context.Context) ApiApiV3AllOrdersGetRequest

	/*
	 * ApiV3AllOrdersGetExecute executes the request
	 * @return []OrderDetails
	 */
	ApiV3AllOrdersGetExecute(r ApiApiV3AllOrdersGetRequest) ([]OrderDetails, *_nethttp.Response, error)

	/*
			 * ApiV3MyTradesGet Account Trade List (USER_DATA)
			 * Get trades for a specific account and symbol.

		If fromId is set, it will get id >= that fromId. Otherwise most recent orders are returned.

		Weight: 5
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3MyTradesGetRequest
	*/
	ApiV3MyTradesGet(ctx _context.Context) ApiApiV3MyTradesGetRequest

	/*
	 * ApiV3MyTradesGetExecute executes the request
	 * @return MyTrade
	 */
	ApiV3MyTradesGetExecute(r ApiApiV3MyTradesGetRequest) (MyTrade, *_nethttp.Response, error)

	/*
	 * ApiV3OpenOrderListGet Query Open OCO (USER_DATA)
	 * Weight: 2
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiApiV3OpenOrderListGetRequest
	 */
	ApiV3OpenOrderListGet(ctx _context.Context) ApiApiV3OpenOrderListGetRequest

	/*
	 * ApiV3OpenOrderListGetExecute executes the request
	 * @return []OCOOrder
	 */
	ApiV3OpenOrderListGetExecute(r ApiApiV3OpenOrderListGetRequest) ([]OCOOrder, *_nethttp.Response, error)

	/*
			 * ApiV3OpenOrdersDelete Cancel all Open Orders on a Symbol (TRADE)
			 * Cancels all active orders on a symbol.\
		This includes OCO orders.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OpenOrdersDeleteRequest
	*/
	ApiV3OpenOrdersDelete(ctx _context.Context) ApiApiV3OpenOrdersDeleteRequest

	/*
	 * ApiV3OpenOrdersDeleteExecute executes the request
	 * @return []Order
	 */
	ApiV3OpenOrdersDeleteExecute(r ApiApiV3OpenOrdersDeleteRequest) ([]Order, *_nethttp.Response, error)

	/*
			 * ApiV3OpenOrdersGet Current Open Orders (USER_DATA)
			 * Get all open orders on a symbol. Careful when accessing this with no symbol.\

		Weight:\
		`1` for a single symbol;\
		`40` when the symbol parameter is omitted
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OpenOrdersGetRequest
	*/
	ApiV3OpenOrdersGet(ctx _context.Context) ApiApiV3OpenOrdersGetRequest

	/*
	 * ApiV3OpenOrdersGetExecute executes the request
	 * @return []OrderDetails
	 */
	ApiV3OpenOrdersGetExecute(r ApiApiV3OpenOrdersGetRequest) ([]OrderDetails, *_nethttp.Response, error)

	/*
			 * ApiV3OrderDelete Cancel Order (TRADE)
			 * Cancel an active order.

		Either `orderId` or `origClientOrderId` must be sent.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderDeleteRequest
	*/
	ApiV3OrderDelete(ctx _context.Context) ApiApiV3OrderDeleteRequest

	/*
	 * ApiV3OrderDeleteExecute executes the request
	 * @return Order
	 */
	ApiV3OrderDeleteExecute(r ApiApiV3OrderDeleteRequest) (Order, *_nethttp.Response, error)

	/*
			 * ApiV3OrderGet Query Order (USER_DATA)
			 * Check an order's status.

		- Either `orderId` or `origClientOrderId` must be sent.
		- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderGetRequest
	*/
	ApiV3OrderGet(ctx _context.Context) ApiApiV3OrderGetRequest

	/*
	 * ApiV3OrderGetExecute executes the request
	 * @return OrderDetails
	 */
	ApiV3OrderGetExecute(r ApiApiV3OrderGetRequest) (OrderDetails, *_nethttp.Response, error)

	/*
			 * ApiV3OrderListDelete Cancel OCO (TRADE)
			 * Cancel an entire Order List

		Canceling an individual leg will cancel the entire OCO

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderListDeleteRequest
	*/
	ApiV3OrderListDelete(ctx _context.Context) ApiApiV3OrderListDeleteRequest

	/*
	 * ApiV3OrderListDeleteExecute executes the request
	 * @return OCOOrderReport
	 */
	ApiV3OrderListDeleteExecute(r ApiApiV3OrderListDeleteRequest) (OCOOrderReport, *_nethttp.Response, error)

	/*
			 * ApiV3OrderListGet Query OCO (USER_DATA)
			 * Retrieves a specific OCO based on provided optional parameters

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderListGetRequest
	*/
	ApiV3OrderListGet(ctx _context.Context) ApiApiV3OrderListGetRequest

	/*
	 * ApiV3OrderListGetExecute executes the request
	 * @return OCOOrder
	 */
	ApiV3OrderListGetExecute(r ApiApiV3OrderListGetRequest) (OCOOrder, *_nethttp.Response, error)

	/*
			 * ApiV3OrderOcoPost New OCO (TRADE)
			 * Send in a new OCO

		- Price Restrictions:
		  - SELL: Limit Price > Last Price > Stop Price
		  - BUY: Limit Price < Last Price < Stop Price
		- Quantity Restrictions:
		    - Both legs must have the same quantity
		    - ICEBERG quantities however do not have to be the same

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderOcoPostRequest
	*/
	ApiV3OrderOcoPost(ctx _context.Context) ApiApiV3OrderOcoPostRequest

	/*
	 * ApiV3OrderOcoPostExecute executes the request
	 * @return InlineResponse2004
	 */
	ApiV3OrderOcoPostExecute(r ApiApiV3OrderOcoPostRequest) (InlineResponse2004, *_nethttp.Response, error)

	/*
			 * ApiV3OrderPost New Order (TRADE)
			 * Send in a new order.


		- `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker.
		- `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached.
		- Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`.
		- Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`.
		- `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price.
		- `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`.
		- `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`.
		- same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.

		Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:

		- Price above market price: STOP_LOSS BUY, TAKE_PROFIT SELL
		- Price below market price: STOP_LOSS SELL, TAKE_PROFIT BUY


		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderPostRequest
	*/
	ApiV3OrderPost(ctx _context.Context) ApiApiV3OrderPostRequest

	/*
	 * ApiV3OrderPostExecute executes the request
	 * @return OrderResponse
	 */
	ApiV3OrderPostExecute(r ApiApiV3OrderPostRequest) (OrderResponse, *_nethttp.Response, error)

	/*
			 * ApiV3OrderTestPost Test New Order (TRADE)
			 * Test new order creation and signature/recvWindow long.
		Creates and validates a new order but does not send it into the matching engine.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiApiV3OrderTestPostRequest
	*/
	ApiV3OrderTestPost(ctx _context.Context) ApiApiV3OrderTestPostRequest

	/*
	 * ApiV3OrderTestPostExecute executes the request
	 */
	ApiV3OrderTestPostExecute(r ApiApiV3OrderTestPostRequest) (*_nethttp.Response, error)
}

// TradeApiService TradeApi service
type TradeApiService service

type ApiApiV3AccountGetRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3AccountGetRequest) RecvWindow(recvWindow int32) ApiApiV3AccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3AccountGetRequest) Timestamp(timestamp int32) ApiApiV3AccountGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3AccountGetRequest) Signature(signature string) ApiApiV3AccountGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3AccountGetRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiV3AccountGetExecute(r)
}

/*
 * ApiV3AccountGet Account Information (USER_DATA)
 * Get current account information.

Weight: 5
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3AccountGetRequest
*/
func (a *TradeApiService) ApiV3AccountGet(ctx _context.Context) ApiApiV3AccountGetRequest {
	return ApiApiV3AccountGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *TradeApiService) ApiV3AccountGetExecute(r ApiApiV3AccountGetRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3AccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3AllOrderListGetRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	fromId     *int32
	startTime  *int32
	endTime    *int32
	limit      *int32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3AllOrderListGetRequest) FromId(fromId int32) ApiApiV3AllOrderListGetRequest {
	r.fromId = &fromId
	return r
}
func (r ApiApiV3AllOrderListGetRequest) StartTime(startTime int32) ApiApiV3AllOrderListGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiApiV3AllOrderListGetRequest) EndTime(endTime int32) ApiApiV3AllOrderListGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiApiV3AllOrderListGetRequest) Limit(limit int32) ApiApiV3AllOrderListGetRequest {
	r.limit = &limit
	return r
}
func (r ApiApiV3AllOrderListGetRequest) RecvWindow(recvWindow int32) ApiApiV3AllOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3AllOrderListGetRequest) Timestamp(timestamp int32) ApiApiV3AllOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3AllOrderListGetRequest) Signature(signature string) ApiApiV3AllOrderListGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3AllOrderListGetRequest) Execute() ([]OCOOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV3AllOrderListGetExecute(r)
}

/*
 * ApiV3AllOrderListGet Query all OCO (USER_DATA)
 * Retrieves all OCO based on provided optional parameters

Weight: 10
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3AllOrderListGetRequest
*/
func (a *TradeApiService) ApiV3AllOrderListGet(ctx _context.Context) ApiApiV3AllOrderListGetRequest {
	return ApiApiV3AllOrderListGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OCOOrder
 */
func (a *TradeApiService) ApiV3AllOrderListGetExecute(r ApiApiV3AllOrderListGetRequest) ([]OCOOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OCOOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3AllOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3AllOrdersGetRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	symbol     *string
	orderId    *int32
	startTime  *int32
	endTime    *int32
	limit      *int32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3AllOrdersGetRequest) Symbol(symbol string) ApiApiV3AllOrdersGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3AllOrdersGetRequest) OrderId(orderId int32) ApiApiV3AllOrdersGetRequest {
	r.orderId = &orderId
	return r
}
func (r ApiApiV3AllOrdersGetRequest) StartTime(startTime int32) ApiApiV3AllOrdersGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiApiV3AllOrdersGetRequest) EndTime(endTime int32) ApiApiV3AllOrdersGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiApiV3AllOrdersGetRequest) Limit(limit int32) ApiApiV3AllOrdersGetRequest {
	r.limit = &limit
	return r
}
func (r ApiApiV3AllOrdersGetRequest) RecvWindow(recvWindow int32) ApiApiV3AllOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3AllOrdersGetRequest) Timestamp(timestamp int32) ApiApiV3AllOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3AllOrdersGetRequest) Signature(signature string) ApiApiV3AllOrdersGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3AllOrdersGetRequest) Execute() ([]OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV3AllOrdersGetExecute(r)
}

/*
 * ApiV3AllOrdersGet All Orders (USER_DATA)
 * Get all account orders; active, canceled, or filled..

- If orderId is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
- For some historical orders cummulativeQuoteQty will be < 0, meaning the data is not available at this time.

Weight: 5
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3AllOrdersGetRequest
*/
func (a *TradeApiService) ApiV3AllOrdersGet(ctx _context.Context) ApiApiV3AllOrdersGetRequest {
	return ApiApiV3AllOrdersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OrderDetails
 */
func (a *TradeApiService) ApiV3AllOrdersGetExecute(r ApiApiV3AllOrdersGetRequest) ([]OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3AllOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3MyTradesGetRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	symbol     *string
	startTime  *int32
	endTime    *int32
	fromId     *int32
	limit      *int32
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3MyTradesGetRequest) Symbol(symbol string) ApiApiV3MyTradesGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3MyTradesGetRequest) StartTime(startTime int32) ApiApiV3MyTradesGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiApiV3MyTradesGetRequest) EndTime(endTime int32) ApiApiV3MyTradesGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiApiV3MyTradesGetRequest) FromId(fromId int32) ApiApiV3MyTradesGetRequest {
	r.fromId = &fromId
	return r
}
func (r ApiApiV3MyTradesGetRequest) Limit(limit int32) ApiApiV3MyTradesGetRequest {
	r.limit = &limit
	return r
}
func (r ApiApiV3MyTradesGetRequest) RecvWindow(recvWindow int32) ApiApiV3MyTradesGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3MyTradesGetRequest) Timestamp(timestamp int32) ApiApiV3MyTradesGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3MyTradesGetRequest) Signature(signature string) ApiApiV3MyTradesGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3MyTradesGetRequest) Execute() (MyTrade, *_nethttp.Response, error) {
	return r.ApiService.ApiV3MyTradesGetExecute(r)
}

/*
 * ApiV3MyTradesGet Account Trade List (USER_DATA)
 * Get trades for a specific account and symbol.

If fromId is set, it will get id >= that fromId. Otherwise most recent orders are returned.

Weight: 5
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3MyTradesGetRequest
*/
func (a *TradeApiService) ApiV3MyTradesGet(ctx _context.Context) ApiApiV3MyTradesGetRequest {
	return ApiApiV3MyTradesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return MyTrade
 */
func (a *TradeApiService) ApiV3MyTradesGetExecute(r ApiApiV3MyTradesGetRequest) (MyTrade, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MyTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3MyTradesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OpenOrderListGetRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3OpenOrderListGetRequest) RecvWindow(recvWindow int32) ApiApiV3OpenOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OpenOrderListGetRequest) Timestamp(timestamp int32) ApiApiV3OpenOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OpenOrderListGetRequest) Signature(signature string) ApiApiV3OpenOrderListGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OpenOrderListGetRequest) Execute() ([]OCOOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OpenOrderListGetExecute(r)
}

/*
 * ApiV3OpenOrderListGet Query Open OCO (USER_DATA)
 * Weight: 2
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OpenOrderListGetRequest
 */
func (a *TradeApiService) ApiV3OpenOrderListGet(ctx _context.Context) ApiApiV3OpenOrderListGetRequest {
	return ApiApiV3OpenOrderListGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OCOOrder
 */
func (a *TradeApiService) ApiV3OpenOrderListGetExecute(r ApiApiV3OpenOrderListGetRequest) ([]OCOOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OCOOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OpenOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OpenOrdersDeleteRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	symbol     *string
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3OpenOrdersDeleteRequest) Symbol(symbol string) ApiApiV3OpenOrdersDeleteRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OpenOrdersDeleteRequest) RecvWindow(recvWindow int32) ApiApiV3OpenOrdersDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OpenOrdersDeleteRequest) Timestamp(timestamp int32) ApiApiV3OpenOrdersDeleteRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OpenOrdersDeleteRequest) Signature(signature string) ApiApiV3OpenOrdersDeleteRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OpenOrdersDeleteRequest) Execute() ([]Order, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OpenOrdersDeleteExecute(r)
}

/*
 * ApiV3OpenOrdersDelete Cancel all Open Orders on a Symbol (TRADE)
 * Cancels all active orders on a symbol.\
This includes OCO orders.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OpenOrdersDeleteRequest
*/
func (a *TradeApiService) ApiV3OpenOrdersDelete(ctx _context.Context) ApiApiV3OpenOrdersDeleteRequest {
	return ApiApiV3OpenOrdersDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []Order
 */
func (a *TradeApiService) ApiV3OpenOrdersDeleteExecute(r ApiApiV3OpenOrdersDeleteRequest) ([]Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OpenOrdersDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OpenOrdersGetRequest struct {
	ctx        _context.Context
	ApiService TradeApi
	symbol     *string
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiApiV3OpenOrdersGetRequest) Symbol(symbol string) ApiApiV3OpenOrdersGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OpenOrdersGetRequest) RecvWindow(recvWindow int32) ApiApiV3OpenOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OpenOrdersGetRequest) Timestamp(timestamp int32) ApiApiV3OpenOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OpenOrdersGetRequest) Signature(signature string) ApiApiV3OpenOrdersGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OpenOrdersGetRequest) Execute() ([]OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OpenOrdersGetExecute(r)
}

/*
 * ApiV3OpenOrdersGet Current Open Orders (USER_DATA)
 * Get all open orders on a symbol. Careful when accessing this with no symbol.\

Weight:\
`1` for a single symbol;\
`40` when the symbol parameter is omitted
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OpenOrdersGetRequest
*/
func (a *TradeApiService) ApiV3OpenOrdersGet(ctx _context.Context) ApiApiV3OpenOrdersGetRequest {
	return ApiApiV3OpenOrdersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []OrderDetails
 */
func (a *TradeApiService) ApiV3OpenOrdersGetExecute(r ApiApiV3OpenOrdersGetRequest) ([]OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OpenOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderDeleteRequest struct {
	ctx               _context.Context
	ApiService        TradeApi
	symbol            *string
	orderId           *int32
	origClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int32
	timestamp         *int32
	signature         *string
}

func (r ApiApiV3OrderDeleteRequest) Symbol(symbol string) ApiApiV3OrderDeleteRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OrderDeleteRequest) OrderId(orderId int32) ApiApiV3OrderDeleteRequest {
	r.orderId = &orderId
	return r
}
func (r ApiApiV3OrderDeleteRequest) OrigClientOrderId(origClientOrderId string) ApiApiV3OrderDeleteRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
func (r ApiApiV3OrderDeleteRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
func (r ApiApiV3OrderDeleteRequest) RecvWindow(recvWindow int32) ApiApiV3OrderDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderDeleteRequest) Timestamp(timestamp int32) ApiApiV3OrderDeleteRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderDeleteRequest) Signature(signature string) ApiApiV3OrderDeleteRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderDeleteRequest) Execute() (Order, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderDeleteExecute(r)
}

/*
 * ApiV3OrderDelete Cancel Order (TRADE)
 * Cancel an active order.

Either `orderId` or `origClientOrderId` must be sent.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderDeleteRequest
*/
func (a *TradeApiService) ApiV3OrderDelete(ctx _context.Context) ApiApiV3OrderDeleteRequest {
	return ApiApiV3OrderDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return Order
 */
func (a *TradeApiService) ApiV3OrderDeleteExecute(r ApiApiV3OrderDeleteRequest) (Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderGetRequest struct {
	ctx               _context.Context
	ApiService        TradeApi
	symbol            *string
	orderId           *int32
	origClientOrderId *string
	recvWindow        *int32
	timestamp         *int32
	signature         *string
}

func (r ApiApiV3OrderGetRequest) Symbol(symbol string) ApiApiV3OrderGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OrderGetRequest) OrderId(orderId int32) ApiApiV3OrderGetRequest {
	r.orderId = &orderId
	return r
}
func (r ApiApiV3OrderGetRequest) OrigClientOrderId(origClientOrderId string) ApiApiV3OrderGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
func (r ApiApiV3OrderGetRequest) RecvWindow(recvWindow int32) ApiApiV3OrderGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderGetRequest) Timestamp(timestamp int32) ApiApiV3OrderGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderGetRequest) Signature(signature string) ApiApiV3OrderGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderGetRequest) Execute() (OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderGetExecute(r)
}

/*
 * ApiV3OrderGet Query Order (USER_DATA)
 * Check an order's status.

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderGetRequest
*/
func (a *TradeApiService) ApiV3OrderGet(ctx _context.Context) ApiApiV3OrderGetRequest {
	return ApiApiV3OrderGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OrderDetails
 */
func (a *TradeApiService) ApiV3OrderGetExecute(r ApiApiV3OrderGetRequest) (OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderListDeleteRequest struct {
	ctx               _context.Context
	ApiService        TradeApi
	symbol            *string
	orderListId       *int32
	listClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int32
	timestamp         *int32
	signature         *string
}

func (r ApiApiV3OrderListDeleteRequest) Symbol(symbol string) ApiApiV3OrderListDeleteRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OrderListDeleteRequest) OrderListId(orderListId int32) ApiApiV3OrderListDeleteRequest {
	r.orderListId = &orderListId
	return r
}
func (r ApiApiV3OrderListDeleteRequest) ListClientOrderId(listClientOrderId string) ApiApiV3OrderListDeleteRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}
func (r ApiApiV3OrderListDeleteRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderListDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
func (r ApiApiV3OrderListDeleteRequest) RecvWindow(recvWindow int32) ApiApiV3OrderListDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderListDeleteRequest) Timestamp(timestamp int32) ApiApiV3OrderListDeleteRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderListDeleteRequest) Signature(signature string) ApiApiV3OrderListDeleteRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderListDeleteRequest) Execute() (OCOOrderReport, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderListDeleteExecute(r)
}

/*
 * ApiV3OrderListDelete Cancel OCO (TRADE)
 * Cancel an entire Order List

Canceling an individual leg will cancel the entire OCO

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderListDeleteRequest
*/
func (a *TradeApiService) ApiV3OrderListDelete(ctx _context.Context) ApiApiV3OrderListDeleteRequest {
	return ApiApiV3OrderListDeleteRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OCOOrderReport
 */
func (a *TradeApiService) ApiV3OrderListDeleteExecute(r ApiApiV3OrderListDeleteRequest) (OCOOrderReport, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OCOOrderReport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderListDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderListGetRequest struct {
	ctx               _context.Context
	ApiService        TradeApi
	orderListId       *int32
	origClientOrderId *string
	recvWindow        *int32
	timestamp         *int32
	signature         *string
}

func (r ApiApiV3OrderListGetRequest) OrderListId(orderListId int32) ApiApiV3OrderListGetRequest {
	r.orderListId = &orderListId
	return r
}
func (r ApiApiV3OrderListGetRequest) OrigClientOrderId(origClientOrderId string) ApiApiV3OrderListGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
func (r ApiApiV3OrderListGetRequest) RecvWindow(recvWindow int32) ApiApiV3OrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderListGetRequest) Timestamp(timestamp int32) ApiApiV3OrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderListGetRequest) Signature(signature string) ApiApiV3OrderListGetRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderListGetRequest) Execute() (OCOOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderListGetExecute(r)
}

/*
 * ApiV3OrderListGet Query OCO (USER_DATA)
 * Retrieves a specific OCO based on provided optional parameters

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderListGetRequest
*/
func (a *TradeApiService) ApiV3OrderListGet(ctx _context.Context) ApiApiV3OrderListGetRequest {
	return ApiApiV3OrderListGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OCOOrder
 */
func (a *TradeApiService) ApiV3OrderListGetExecute(r ApiApiV3OrderListGetRequest) (OCOOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OCOOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderOcoPostRequest struct {
	ctx                  _context.Context
	ApiService           TradeApi
	symbol               *string
	side                 *string
	quantity             *float32
	price                *float32
	stopPrice            *float32
	listClientOrderId    *string
	limitClientOrderId   *float32
	limitIcebergQty      *float32
	stopClientOrderId    *string
	stopLimitPrice       *float32
	stopIcebergQty       *float32
	stopLimitTimeInForce *string
	newOrderRespType     *string
	recvWindow           *int32
	timestamp            *int32
	signature            *string
}

func (r ApiApiV3OrderOcoPostRequest) Symbol(symbol string) ApiApiV3OrderOcoPostRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OrderOcoPostRequest) Side(side string) ApiApiV3OrderOcoPostRequest {
	r.side = &side
	return r
}
func (r ApiApiV3OrderOcoPostRequest) Quantity(quantity float32) ApiApiV3OrderOcoPostRequest {
	r.quantity = &quantity
	return r
}
func (r ApiApiV3OrderOcoPostRequest) Price(price float32) ApiApiV3OrderOcoPostRequest {
	r.price = &price
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopPrice(stopPrice float32) ApiApiV3OrderOcoPostRequest {
	r.stopPrice = &stopPrice
	return r
}
func (r ApiApiV3OrderOcoPostRequest) ListClientOrderId(listClientOrderId string) ApiApiV3OrderOcoPostRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}
func (r ApiApiV3OrderOcoPostRequest) LimitClientOrderId(limitClientOrderId float32) ApiApiV3OrderOcoPostRequest {
	r.limitClientOrderId = &limitClientOrderId
	return r
}
func (r ApiApiV3OrderOcoPostRequest) LimitIcebergQty(limitIcebergQty float32) ApiApiV3OrderOcoPostRequest {
	r.limitIcebergQty = &limitIcebergQty
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopClientOrderId(stopClientOrderId string) ApiApiV3OrderOcoPostRequest {
	r.stopClientOrderId = &stopClientOrderId
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopLimitPrice(stopLimitPrice float32) ApiApiV3OrderOcoPostRequest {
	r.stopLimitPrice = &stopLimitPrice
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopIcebergQty(stopIcebergQty float32) ApiApiV3OrderOcoPostRequest {
	r.stopIcebergQty = &stopIcebergQty
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopLimitTimeInForce(stopLimitTimeInForce string) ApiApiV3OrderOcoPostRequest {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}
func (r ApiApiV3OrderOcoPostRequest) NewOrderRespType(newOrderRespType string) ApiApiV3OrderOcoPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
func (r ApiApiV3OrderOcoPostRequest) RecvWindow(recvWindow int32) ApiApiV3OrderOcoPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderOcoPostRequest) Timestamp(timestamp int32) ApiApiV3OrderOcoPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderOcoPostRequest) Signature(signature string) ApiApiV3OrderOcoPostRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderOcoPostRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderOcoPostExecute(r)
}

/*
 * ApiV3OrderOcoPost New OCO (TRADE)
 * Send in a new OCO

- Price Restrictions:
  - SELL: Limit Price > Last Price > Stop Price
  - BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
    - Both legs must have the same quantity
    - ICEBERG quantities however do not have to be the same

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderOcoPostRequest
*/
func (a *TradeApiService) ApiV3OrderOcoPost(ctx _context.Context) ApiApiV3OrderOcoPostRequest {
	return ApiApiV3OrderOcoPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2004
 */
func (a *TradeApiService) ApiV3OrderOcoPostExecute(r ApiApiV3OrderOcoPostRequest) (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderOcoPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.limitClientOrderId != nil {
		localVarQueryParams.Add("limitClientOrderId", parameterToString(*r.limitClientOrderId, ""))
	}
	localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	if r.limitIcebergQty != nil {
		localVarQueryParams.Add("limitIcebergQty", parameterToString(*r.limitIcebergQty, ""))
	}
	if r.stopClientOrderId != nil {
		localVarQueryParams.Add("stopClientOrderId", parameterToString(*r.stopClientOrderId, ""))
	}
	localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	if r.stopLimitPrice != nil {
		localVarQueryParams.Add("stopLimitPrice", parameterToString(*r.stopLimitPrice, ""))
	}
	if r.stopIcebergQty != nil {
		localVarQueryParams.Add("stopIcebergQty", parameterToString(*r.stopIcebergQty, ""))
	}
	if r.stopLimitTimeInForce != nil {
		localVarQueryParams.Add("stopLimitTimeInForce", parameterToString(*r.stopLimitTimeInForce, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderPostRequest struct {
	ctx              _context.Context
	ApiService       TradeApi
	symbol           *string
	side             *string
	type_            *string
	timeInForce      *string
	quantity         *float32
	quoteOrderQty    *float32
	price            *float32
	newClientOrderId *string
	stopPrice        *float32
	icebergQty       *float32
	newOrderRespType *string
	recvWindow       *int32
	timestamp        *int32
	signature        *string
}

func (r ApiApiV3OrderPostRequest) Symbol(symbol string) ApiApiV3OrderPostRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OrderPostRequest) Side(side string) ApiApiV3OrderPostRequest {
	r.side = &side
	return r
}
func (r ApiApiV3OrderPostRequest) Type_(type_ string) ApiApiV3OrderPostRequest {
	r.type_ = &type_
	return r
}
func (r ApiApiV3OrderPostRequest) TimeInForce(timeInForce string) ApiApiV3OrderPostRequest {
	r.timeInForce = &timeInForce
	return r
}
func (r ApiApiV3OrderPostRequest) Quantity(quantity float32) ApiApiV3OrderPostRequest {
	r.quantity = &quantity
	return r
}
func (r ApiApiV3OrderPostRequest) QuoteOrderQty(quoteOrderQty float32) ApiApiV3OrderPostRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}
func (r ApiApiV3OrderPostRequest) Price(price float32) ApiApiV3OrderPostRequest {
	r.price = &price
	return r
}
func (r ApiApiV3OrderPostRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderPostRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
func (r ApiApiV3OrderPostRequest) StopPrice(stopPrice float32) ApiApiV3OrderPostRequest {
	r.stopPrice = &stopPrice
	return r
}
func (r ApiApiV3OrderPostRequest) IcebergQty(icebergQty float32) ApiApiV3OrderPostRequest {
	r.icebergQty = &icebergQty
	return r
}
func (r ApiApiV3OrderPostRequest) NewOrderRespType(newOrderRespType string) ApiApiV3OrderPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
func (r ApiApiV3OrderPostRequest) RecvWindow(recvWindow int32) ApiApiV3OrderPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderPostRequest) Timestamp(timestamp int32) ApiApiV3OrderPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderPostRequest) Signature(signature string) ApiApiV3OrderPostRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderPostRequest) Execute() (OrderResponse, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderPostExecute(r)
}

/*
 * ApiV3OrderPost New Order (TRADE)
 * Send in a new order.


- `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker.
- `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached.
- Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`.
- Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`.
- `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price.
- `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`.
- `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`.
- same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.

Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:

- Price above market price: STOP_LOSS BUY, TAKE_PROFIT SELL
- Price below market price: STOP_LOSS SELL, TAKE_PROFIT BUY


Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderPostRequest
*/
func (a *TradeApiService) ApiV3OrderPost(ctx _context.Context) ApiApiV3OrderPostRequest {
	return ApiApiV3OrderPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return OrderResponse
 */
func (a *TradeApiService) ApiV3OrderPostExecute(r ApiApiV3OrderPostRequest) (OrderResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.quantity != nil {
		localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	}
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderTestPostRequest struct {
	ctx              _context.Context
	ApiService       TradeApi
	symbol           *string
	side             *string
	type_            *string
	timeInForce      *string
	quantity         *float32
	quoteOrderQty    *float32
	price            *float32
	newClientOrderId *string
	stopPrice        *float32
	icebergQty       *float32
	newOrderRespType *string
	recvWindow       *int32
	timestamp        *int32
	signature        *string
}

func (r ApiApiV3OrderTestPostRequest) Symbol(symbol string) ApiApiV3OrderTestPostRequest {
	r.symbol = &symbol
	return r
}
func (r ApiApiV3OrderTestPostRequest) Side(side string) ApiApiV3OrderTestPostRequest {
	r.side = &side
	return r
}
func (r ApiApiV3OrderTestPostRequest) Type_(type_ string) ApiApiV3OrderTestPostRequest {
	r.type_ = &type_
	return r
}
func (r ApiApiV3OrderTestPostRequest) TimeInForce(timeInForce string) ApiApiV3OrderTestPostRequest {
	r.timeInForce = &timeInForce
	return r
}
func (r ApiApiV3OrderTestPostRequest) Quantity(quantity float32) ApiApiV3OrderTestPostRequest {
	r.quantity = &quantity
	return r
}
func (r ApiApiV3OrderTestPostRequest) QuoteOrderQty(quoteOrderQty float32) ApiApiV3OrderTestPostRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}
func (r ApiApiV3OrderTestPostRequest) Price(price float32) ApiApiV3OrderTestPostRequest {
	r.price = &price
	return r
}
func (r ApiApiV3OrderTestPostRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderTestPostRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
func (r ApiApiV3OrderTestPostRequest) StopPrice(stopPrice float32) ApiApiV3OrderTestPostRequest {
	r.stopPrice = &stopPrice
	return r
}
func (r ApiApiV3OrderTestPostRequest) IcebergQty(icebergQty float32) ApiApiV3OrderTestPostRequest {
	r.icebergQty = &icebergQty
	return r
}
func (r ApiApiV3OrderTestPostRequest) NewOrderRespType(newOrderRespType string) ApiApiV3OrderTestPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
func (r ApiApiV3OrderTestPostRequest) RecvWindow(recvWindow int32) ApiApiV3OrderTestPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiApiV3OrderTestPostRequest) Timestamp(timestamp int32) ApiApiV3OrderTestPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiApiV3OrderTestPostRequest) Signature(signature string) ApiApiV3OrderTestPostRequest {
	r.signature = &signature
	return r
}

func (r ApiApiV3OrderTestPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderTestPostExecute(r)
}

/*
 * ApiV3OrderTestPost Test New Order (TRADE)
 * Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiApiV3OrderTestPostRequest
*/
func (a *TradeApiService) ApiV3OrderTestPost(ctx _context.Context) ApiApiV3OrderTestPostRequest {
	return ApiApiV3OrderTestPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *TradeApiService) ApiV3OrderTestPostExecute(r ApiApiV3OrderTestPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderTestPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return nil, reportError("type_ is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.quantity != nil {
		localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	}
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
