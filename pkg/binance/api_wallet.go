/*
 * Binance SPOT Public API
 *
 * The swagger file of Binance Public API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)
 *
 * API version: 1.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binance

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

type WalletApi interface {

	/*
			 * SapiV1AccountDisableFastWithdrawSwitchPost Disable Fast Withdraw Switch (USER_DATA)
			 * This request will disable fastwithdraw switch under your account.
		You need to enable "trade" option for the api key which requests this endpoint.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest
	*/
	SapiV1AccountDisableFastWithdrawSwitchPost(ctx _context.Context) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest

	/*
	 * SapiV1AccountDisableFastWithdrawSwitchPostExecute executes the request
	 */
	SapiV1AccountDisableFastWithdrawSwitchPostExecute(r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) (*_nethttp.Response, error)

	/*
			 * SapiV1AccountEnableFastWithdrawSwitchPost Enable Fast Withdraw Switch (USER_DATA)
			 *
		- This request will enable fastwithdraw switch under your account. You need to enable "trade" option for the api key which requests this endpoint.
		- When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest
	*/
	SapiV1AccountEnableFastWithdrawSwitchPost(ctx _context.Context) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest

	/*
	 * SapiV1AccountEnableFastWithdrawSwitchPostExecute executes the request
	 */
	SapiV1AccountEnableFastWithdrawSwitchPostExecute(r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) (*_nethttp.Response, error)

	/*
			 * SapiV1AccountSnapshotGet Daily Account Snapshot (USER_DATA)
			 *
		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1AccountSnapshotGetRequest
	*/
	SapiV1AccountSnapshotGet(ctx _context.Context) ApiSapiV1AccountSnapshotGetRequest

	/*
	 * SapiV1AccountSnapshotGetExecute executes the request
	 * @return InlineResponse20014
	 */
	SapiV1AccountSnapshotGetExecute(r ApiSapiV1AccountSnapshotGetRequest) (InlineResponse20014, *_nethttp.Response, error)

	/*
			 * SapiV1AssetAssetDividendGet Dust Transfer
			 * Query asset Dividend Record

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1AssetAssetDividendGetRequest
	*/
	SapiV1AssetAssetDividendGet(ctx _context.Context) ApiSapiV1AssetAssetDividendGetRequest

	/*
	 * SapiV1AssetAssetDividendGetExecute executes the request
	 * @return InlineResponse20023
	 */
	SapiV1AssetAssetDividendGetExecute(r ApiSapiV1AssetAssetDividendGetRequest) (InlineResponse20023, *_nethttp.Response, error)

	/*
			 * SapiV1AssetDustPost Dust Transfer
			 * Convert dust assets to BNB.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1AssetDustPostRequest
	*/
	SapiV1AssetDustPost(ctx _context.Context) ApiSapiV1AssetDustPostRequest

	/*
	 * SapiV1AssetDustPostExecute executes the request
	 * @return InlineResponse20022
	 */
	SapiV1AssetDustPostExecute(r ApiSapiV1AssetDustPostRequest) (InlineResponse20022, *_nethttp.Response, error)

	/*
			 * SapiV1CapitalConfigGetallGet All Coins' Information (USER_DATA)
			 * Get information of coins (available for deposit and withdraw) for user.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1CapitalConfigGetallGetRequest
	*/
	SapiV1CapitalConfigGetallGet(ctx _context.Context) ApiSapiV1CapitalConfigGetallGetRequest

	/*
	 * SapiV1CapitalConfigGetallGetExecute executes the request
	 * @return InlineResponse20013
	 */
	SapiV1CapitalConfigGetallGetExecute(r ApiSapiV1CapitalConfigGetallGetRequest) (InlineResponse20013, *_nethttp.Response, error)

	/*
			 * SapiV1CapitalDepositAddressGet Withdraw History (supporting network) (USER_DATA)
			 * Fetch withdraw history.

		- network may not be in the response for old withdraw.
		- Please notice the default startTime and endTime to make sure that time interval is within 0-90 days.
		- If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1CapitalDepositAddressGetRequest
	*/
	SapiV1CapitalDepositAddressGet(ctx _context.Context) ApiSapiV1CapitalDepositAddressGetRequest

	/*
	 * SapiV1CapitalDepositAddressGetExecute executes the request
	 * @return InlineResponse20018
	 */
	SapiV1CapitalDepositAddressGetExecute(r ApiSapiV1CapitalDepositAddressGetRequest) (InlineResponse20018, *_nethttp.Response, error)

	/*
			 * SapiV1CapitalDepositHisrecGet Deposit History（supporting network） (USER_DATA)
			 * Fetch deposit history.

		- Please notice the default startTime and endTime to make sure that time interval is within 0-90 days.
		- If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1CapitalDepositHisrecGetRequest
	*/
	SapiV1CapitalDepositHisrecGet(ctx _context.Context) ApiSapiV1CapitalDepositHisrecGetRequest

	/*
	 * SapiV1CapitalDepositHisrecGetExecute executes the request
	 * @return []InlineResponse20016
	 */
	SapiV1CapitalDepositHisrecGetExecute(r ApiSapiV1CapitalDepositHisrecGetRequest) ([]InlineResponse20016, *_nethttp.Response, error)

	/*
			 * SapiV1CapitalWithdrawApplyPost Withdraw
			 * Submit a withdraw request.

		- If network not send, return with default network of the coin.
		- You can get network and isDefault in networkList of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1CapitalWithdrawApplyPostRequest
	*/
	SapiV1CapitalWithdrawApplyPost(ctx _context.Context) ApiSapiV1CapitalWithdrawApplyPostRequest

	/*
	 * SapiV1CapitalWithdrawApplyPostExecute executes the request
	 * @return InlineResponse20015
	 */
	SapiV1CapitalWithdrawApplyPostExecute(r ApiSapiV1CapitalWithdrawApplyPostRequest) (InlineResponse20015, *_nethttp.Response, error)

	/*
			 * SapiV1CapitalWithdrawHistoryGet Withdraw History (supporting network) (USER_DATA)
			 * Fetch withdraw history.

		- network may not be in the response for old withdraw.
		- Please notice the default startTime and endTime to make sure that time interval is within 0-90 days.
		- If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiSapiV1CapitalWithdrawHistoryGetRequest
	*/
	SapiV1CapitalWithdrawHistoryGet(ctx _context.Context) ApiSapiV1CapitalWithdrawHistoryGetRequest

	/*
	 * SapiV1CapitalWithdrawHistoryGetExecute executes the request
	 * @return []InlineResponse20017
	 */
	SapiV1CapitalWithdrawHistoryGetExecute(r ApiSapiV1CapitalWithdrawHistoryGetRequest) ([]InlineResponse20017, *_nethttp.Response, error)

	/*
			 * WapiV3AccountStatusHtmlGet Account Status (USER_DATA)
			 * Fetch account status detail.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiWapiV3AccountStatusHtmlGetRequest
	*/
	WapiV3AccountStatusHtmlGet(ctx _context.Context) ApiWapiV3AccountStatusHtmlGetRequest

	/*
	 * WapiV3AccountStatusHtmlGetExecute executes the request
	 * @return InlineResponse20019
	 */
	WapiV3AccountStatusHtmlGetExecute(r ApiWapiV3AccountStatusHtmlGetRequest) (InlineResponse20019, *_nethttp.Response, error)

	/*
			 * WapiV3ApiTradingStatusHtmlGet Account API Trading Status (USER_DATA)
			 * Fetch account api trading status detail.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiWapiV3ApiTradingStatusHtmlGetRequest
	*/
	WapiV3ApiTradingStatusHtmlGet(ctx _context.Context) ApiWapiV3ApiTradingStatusHtmlGetRequest

	/*
	 * WapiV3ApiTradingStatusHtmlGetExecute executes the request
	 * @return InlineResponse20020
	 */
	WapiV3ApiTradingStatusHtmlGetExecute(r ApiWapiV3ApiTradingStatusHtmlGetRequest) (InlineResponse20020, *_nethttp.Response, error)

	/*
			 * WapiV3AssetDetailHtmlGet Asset Detail (USER_DATA)
			 * Fetch details of assets supported on Binance.

		Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiWapiV3AssetDetailHtmlGetRequest
	*/
	WapiV3AssetDetailHtmlGet(ctx _context.Context) ApiWapiV3AssetDetailHtmlGetRequest

	/*
	 * WapiV3AssetDetailHtmlGetExecute executes the request
	 * @return InlineResponse20024
	 */
	WapiV3AssetDetailHtmlGetExecute(r ApiWapiV3AssetDetailHtmlGetRequest) (InlineResponse20024, *_nethttp.Response, error)

	/*
	 * WapiV3SystemStatusHtmlGet System Status (System)
	 * Weight: 1
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiWapiV3SystemStatusHtmlGetRequest
	 */
	WapiV3SystemStatusHtmlGet(ctx _context.Context) ApiWapiV3SystemStatusHtmlGetRequest

	/*
	 * WapiV3SystemStatusHtmlGetExecute executes the request
	 * @return map[string]interface{}
	 */
	WapiV3SystemStatusHtmlGetExecute(r ApiWapiV3SystemStatusHtmlGetRequest) (map[string]interface{}, *_nethttp.Response, error)

	/*
			 * WapiV3TradeFeeHtmlGet Trade Fee (USER_DATA)
			 * Fetch trade fee, values in percentage.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiWapiV3TradeFeeHtmlGetRequest
	*/
	WapiV3TradeFeeHtmlGet(ctx _context.Context) ApiWapiV3TradeFeeHtmlGetRequest

	/*
	 * WapiV3TradeFeeHtmlGetExecute executes the request
	 * @return InlineResponse20025
	 */
	WapiV3TradeFeeHtmlGetExecute(r ApiWapiV3TradeFeeHtmlGetRequest) (InlineResponse20025, *_nethttp.Response, error)

	/*
			 * WapiV3UserAssetDribbletLogHtmlGet DustLog (USER_DATA)
			 * Fetch small amounts of assets exchanged BNB records.

		Weight: 1
			 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			 * @return ApiWapiV3UserAssetDribbletLogHtmlGetRequest
	*/
	WapiV3UserAssetDribbletLogHtmlGet(ctx _context.Context) ApiWapiV3UserAssetDribbletLogHtmlGetRequest

	/*
	 * WapiV3UserAssetDribbletLogHtmlGetExecute executes the request
	 * @return InlineResponse20021
	 */
	WapiV3UserAssetDribbletLogHtmlGetExecute(r ApiWapiV3UserAssetDribbletLogHtmlGetRequest) (InlineResponse20021, *_nethttp.Response, error)
}

// WalletApiService WalletApi service
type WalletApiService service

type ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) Timestamp(timestamp int32) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) RecvWindow(recvWindow int32) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) Signature(signature string) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountDisableFastWithdrawSwitchPostExecute(r)
}

/*
 * SapiV1AccountDisableFastWithdrawSwitchPost Disable Fast Withdraw Switch (USER_DATA)
 * This request will disable fastwithdraw switch under your account.
You need to enable "trade" option for the api key which requests this endpoint.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest
*/
func (a *WalletApiService) SapiV1AccountDisableFastWithdrawSwitchPost(ctx _context.Context) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	return ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *WalletApiService) SapiV1AccountDisableFastWithdrawSwitchPostExecute(r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountDisableFastWithdrawSwitchPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/disableFastWithdrawSwitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) Timestamp(timestamp int32) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) RecvWindow(recvWindow int32) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) Signature(signature string) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountEnableFastWithdrawSwitchPostExecute(r)
}

/*
 * SapiV1AccountEnableFastWithdrawSwitchPost Enable Fast Withdraw Switch (USER_DATA)
 *
- This request will enable fastwithdraw switch under your account. You need to enable "trade" option for the api key which requests this endpoint.
- When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest
*/
func (a *WalletApiService) SapiV1AccountEnableFastWithdrawSwitchPost(ctx _context.Context) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	return ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *WalletApiService) SapiV1AccountEnableFastWithdrawSwitchPostExecute(r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountEnableFastWithdrawSwitchPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/enableFastWithdrawSwitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSapiV1AccountSnapshotGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	type_      *string
	limit      *int32
	startTime  *int32
	endTime    *int32
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1AccountSnapshotGetRequest) Type_(type_ string) ApiSapiV1AccountSnapshotGetRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) Limit(limit int32) ApiSapiV1AccountSnapshotGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) StartTime(startTime int32) ApiSapiV1AccountSnapshotGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) EndTime(endTime int32) ApiSapiV1AccountSnapshotGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) Timestamp(timestamp int32) ApiSapiV1AccountSnapshotGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) RecvWindow(recvWindow int32) ApiSapiV1AccountSnapshotGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) Signature(signature string) ApiSapiV1AccountSnapshotGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1AccountSnapshotGetRequest) Execute() (InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountSnapshotGetExecute(r)
}

/*
 * SapiV1AccountSnapshotGet Daily Account Snapshot (USER_DATA)
 *
Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1AccountSnapshotGetRequest
*/
func (a *WalletApiService) SapiV1AccountSnapshotGet(ctx _context.Context) ApiSapiV1AccountSnapshotGetRequest {
	return ApiSapiV1AccountSnapshotGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20014
 */
func (a *WalletApiService) SapiV1AccountSnapshotGetExecute(r ApiSapiV1AccountSnapshotGetRequest) (InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/accountSnapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if *r.limit < 5 {
		return localVarReturnValue, nil, reportError("limit must be greater than 5")
	}
	if *r.limit > 30 {
		return localVarReturnValue, nil, reportError("limit must be less than 30")
	}

	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetAssetDividendGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	limit      *string
	asset      *string
	startTime  *int32
	endTime    *int32
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1AssetAssetDividendGetRequest) Limit(limit string) ApiSapiV1AssetAssetDividendGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) Asset(asset string) ApiSapiV1AssetAssetDividendGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) StartTime(startTime int32) ApiSapiV1AssetAssetDividendGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) EndTime(endTime int32) ApiSapiV1AssetAssetDividendGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) Timestamp(timestamp int32) ApiSapiV1AssetAssetDividendGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) RecvWindow(recvWindow int32) ApiSapiV1AssetAssetDividendGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) Signature(signature string) ApiSapiV1AssetAssetDividendGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1AssetAssetDividendGetRequest) Execute() (InlineResponse20023, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetAssetDividendGetExecute(r)
}

/*
 * SapiV1AssetAssetDividendGet Dust Transfer
 * Query asset Dividend Record

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1AssetAssetDividendGetRequest
*/
func (a *WalletApiService) SapiV1AssetAssetDividendGet(ctx _context.Context) ApiSapiV1AssetAssetDividendGetRequest {
	return ApiSapiV1AssetAssetDividendGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20023
 */
func (a *WalletApiService) SapiV1AssetAssetDividendGetExecute(r ApiSapiV1AssetAssetDividendGetRequest) (InlineResponse20023, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20023
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetAssetDividendGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDividend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	limitTxt, err := atoi(*r.limit)
	if limitTxt > 50 {
		return localVarReturnValue, nil, reportError("limit must be less than 50")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetDustPostRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	asset      *string
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1AssetDustPostRequest) Asset(asset string) ApiSapiV1AssetDustPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1AssetDustPostRequest) Timestamp(timestamp int32) ApiSapiV1AssetDustPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1AssetDustPostRequest) RecvWindow(recvWindow int32) ApiSapiV1AssetDustPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1AssetDustPostRequest) Signature(signature string) ApiSapiV1AssetDustPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1AssetDustPostRequest) Execute() (InlineResponse20022, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetDustPostExecute(r)
}

/*
 * SapiV1AssetDustPost Dust Transfer
 * Convert dust assets to BNB.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1AssetDustPostRequest
*/
func (a *WalletApiService) SapiV1AssetDustPost(ctx _context.Context) ApiSapiV1AssetDustPostRequest {
	return ApiSapiV1AssetDustPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20022
 */
func (a *WalletApiService) SapiV1AssetDustPostExecute(r ApiSapiV1AssetDustPostRequest) (InlineResponse20022, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20022
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetDustPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalConfigGetallGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	recvWindow *int32
	timestamp  *int32
	signature  *string
}

func (r ApiSapiV1CapitalConfigGetallGetRequest) RecvWindow(recvWindow int32) ApiSapiV1CapitalConfigGetallGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1CapitalConfigGetallGetRequest) Timestamp(timestamp int32) ApiSapiV1CapitalConfigGetallGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1CapitalConfigGetallGetRequest) Signature(signature string) ApiSapiV1CapitalConfigGetallGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1CapitalConfigGetallGetRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalConfigGetallGetExecute(r)
}

/*
 * SapiV1CapitalConfigGetallGet All Coins' Information (USER_DATA)
 * Get information of coins (available for deposit and withdraw) for user.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1CapitalConfigGetallGetRequest
*/
func (a *WalletApiService) SapiV1CapitalConfigGetallGet(ctx _context.Context) ApiSapiV1CapitalConfigGetallGetRequest {
	return ApiSapiV1CapitalConfigGetallGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20013
 */
func (a *WalletApiService) SapiV1CapitalConfigGetallGetExecute(r ApiSapiV1CapitalConfigGetallGetRequest) (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalConfigGetallGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/config/getall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalDepositAddressGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	coin       *string
	network    *string
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1CapitalDepositAddressGetRequest) Coin(coin string) ApiSapiV1CapitalDepositAddressGetRequest {
	r.coin = &coin
	return r
}
func (r ApiSapiV1CapitalDepositAddressGetRequest) Network(network string) ApiSapiV1CapitalDepositAddressGetRequest {
	r.network = &network
	return r
}
func (r ApiSapiV1CapitalDepositAddressGetRequest) Timestamp(timestamp int32) ApiSapiV1CapitalDepositAddressGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1CapitalDepositAddressGetRequest) RecvWindow(recvWindow int32) ApiSapiV1CapitalDepositAddressGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1CapitalDepositAddressGetRequest) Signature(signature string) ApiSapiV1CapitalDepositAddressGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1CapitalDepositAddressGetRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalDepositAddressGetExecute(r)
}

/*
 * SapiV1CapitalDepositAddressGet Withdraw History (supporting network) (USER_DATA)
 * Fetch withdraw history.

- network may not be in the response for old withdraw.
- Please notice the default startTime and endTime to make sure that time interval is within 0-90 days.
- If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1CapitalDepositAddressGetRequest
*/
func (a *WalletApiService) SapiV1CapitalDepositAddressGet(ctx _context.Context) ApiSapiV1CapitalDepositAddressGetRequest {
	return ApiSapiV1CapitalDepositAddressGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20018
 */
func (a *WalletApiService) SapiV1CapitalDepositAddressGetExecute(r ApiSapiV1CapitalDepositAddressGetRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalDepositAddressGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}

	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalDepositHisrecGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	coin       *string
	status     *int32
	startTime  *int32
	endTime    *int32
	offset     *int32
	limit      *int32
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1CapitalDepositHisrecGetRequest) Coin(coin string) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.coin = &coin
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Status(status int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.status = &status
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) StartTime(startTime int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) EndTime(endTime int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Offset(offset int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.offset = &offset
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Limit(limit int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Timestamp(timestamp int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) RecvWindow(recvWindow int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Signature(signature string) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1CapitalDepositHisrecGetRequest) Execute() ([]InlineResponse20016, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalDepositHisrecGetExecute(r)
}

/*
 * SapiV1CapitalDepositHisrecGet Deposit History（supporting network） (USER_DATA)
 * Fetch deposit history.

- Please notice the default startTime and endTime to make sure that time interval is within 0-90 days.
- If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1CapitalDepositHisrecGetRequest
*/
func (a *WalletApiService) SapiV1CapitalDepositHisrecGet(ctx _context.Context) ApiSapiV1CapitalDepositHisrecGetRequest {
	return ApiSapiV1CapitalDepositHisrecGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse20016
 */
func (a *WalletApiService) SapiV1CapitalDepositHisrecGetExecute(r ApiSapiV1CapitalDepositHisrecGetRequest) ([]InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalDepositHisrecGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/hisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalWithdrawApplyPostRequest struct {
	ctx                _context.Context
	ApiService         WalletApi
	coin               *string
	address            *string
	amount             *float32
	withdrawOrderId    *string
	network            *string
	addressTag         *string
	transactionFeeFlag *bool
	name               *string
	timestamp          *int32
	recvWindow         *int32
	signature          *string
}

func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Coin(coin string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.coin = &coin
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Address(address string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.address = &address
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Amount(amount float32) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.amount = &amount
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) WithdrawOrderId(withdrawOrderId string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.withdrawOrderId = &withdrawOrderId
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Network(network string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.network = &network
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) AddressTag(addressTag string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.addressTag = &addressTag
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) TransactionFeeFlag(transactionFeeFlag bool) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.transactionFeeFlag = &transactionFeeFlag
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Name(name string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.name = &name
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Timestamp(timestamp int32) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) RecvWindow(recvWindow int32) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Signature(signature string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Execute() (InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalWithdrawApplyPostExecute(r)
}

/*
 * SapiV1CapitalWithdrawApplyPost Withdraw
 * Submit a withdraw request.

- If network not send, return with default network of the coin.
- You can get network and isDefault in networkList of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1CapitalWithdrawApplyPostRequest
*/
func (a *WalletApiService) SapiV1CapitalWithdrawApplyPost(ctx _context.Context) ApiSapiV1CapitalWithdrawApplyPostRequest {
	return ApiSapiV1CapitalWithdrawApplyPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20015
 */
func (a *WalletApiService) SapiV1CapitalWithdrawApplyPostExecute(r ApiSapiV1CapitalWithdrawApplyPostRequest) (InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalWithdrawApplyPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}

	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.withdrawOrderId != nil {
		localVarQueryParams.Add("withdrawOrderId", parameterToString(*r.withdrawOrderId, ""))
	}
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	if r.addressTag != nil {
		localVarQueryParams.Add("addressTag", parameterToString(*r.addressTag, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.transactionFeeFlag != nil {
		localVarQueryParams.Add("transactionFeeFlag", parameterToString(*r.transactionFeeFlag, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalWithdrawHistoryGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	coin       *string
	status     *int32
	startTime  *int32
	endTime    *int32
	offset     *int32
	limit      *int32
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Coin(coin string) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.coin = &coin
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Status(status int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.status = &status
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) StartTime(startTime int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.startTime = &startTime
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) EndTime(endTime int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Offset(offset int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.offset = &offset
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Limit(limit int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Timestamp(timestamp int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) RecvWindow(recvWindow int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Signature(signature string) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.signature = &signature
	return r
}

func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Execute() ([]InlineResponse20017, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalWithdrawHistoryGetExecute(r)
}

/*
 * SapiV1CapitalWithdrawHistoryGet Withdraw History (supporting network) (USER_DATA)
 * Fetch withdraw history.

- network may not be in the response for old withdraw.
- Please notice the default startTime and endTime to make sure that time interval is within 0-90 days.
- If both startTime and endTime are sent, time between startTime and endTime must be less than 90 days

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSapiV1CapitalWithdrawHistoryGetRequest
*/
func (a *WalletApiService) SapiV1CapitalWithdrawHistoryGet(ctx _context.Context) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	return ApiSapiV1CapitalWithdrawHistoryGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse20017
 */
func (a *WalletApiService) SapiV1CapitalWithdrawHistoryGetExecute(r ApiSapiV1CapitalWithdrawHistoryGetRequest) ([]InlineResponse20017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalWithdrawHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWapiV3AccountStatusHtmlGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiWapiV3AccountStatusHtmlGetRequest) Timestamp(timestamp int32) ApiWapiV3AccountStatusHtmlGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiWapiV3AccountStatusHtmlGetRequest) RecvWindow(recvWindow int32) ApiWapiV3AccountStatusHtmlGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiWapiV3AccountStatusHtmlGetRequest) Signature(signature string) ApiWapiV3AccountStatusHtmlGetRequest {
	r.signature = &signature
	return r
}

func (r ApiWapiV3AccountStatusHtmlGetRequest) Execute() (InlineResponse20019, *_nethttp.Response, error) {
	return r.ApiService.WapiV3AccountStatusHtmlGetExecute(r)
}

/*
 * WapiV3AccountStatusHtmlGet Account Status (USER_DATA)
 * Fetch account status detail.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWapiV3AccountStatusHtmlGetRequest
*/
func (a *WalletApiService) WapiV3AccountStatusHtmlGet(ctx _context.Context) ApiWapiV3AccountStatusHtmlGetRequest {
	return ApiWapiV3AccountStatusHtmlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20019
 */
func (a *WalletApiService) WapiV3AccountStatusHtmlGetExecute(r ApiWapiV3AccountStatusHtmlGetRequest) (InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20019
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.WapiV3AccountStatusHtmlGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wapi/v3/accountStatus.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWapiV3ApiTradingStatusHtmlGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiWapiV3ApiTradingStatusHtmlGetRequest) Timestamp(timestamp int32) ApiWapiV3ApiTradingStatusHtmlGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiWapiV3ApiTradingStatusHtmlGetRequest) RecvWindow(recvWindow int32) ApiWapiV3ApiTradingStatusHtmlGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiWapiV3ApiTradingStatusHtmlGetRequest) Signature(signature string) ApiWapiV3ApiTradingStatusHtmlGetRequest {
	r.signature = &signature
	return r
}

func (r ApiWapiV3ApiTradingStatusHtmlGetRequest) Execute() (InlineResponse20020, *_nethttp.Response, error) {
	return r.ApiService.WapiV3ApiTradingStatusHtmlGetExecute(r)
}

/*
 * WapiV3ApiTradingStatusHtmlGet Account API Trading Status (USER_DATA)
 * Fetch account api trading status detail.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWapiV3ApiTradingStatusHtmlGetRequest
*/
func (a *WalletApiService) WapiV3ApiTradingStatusHtmlGet(ctx _context.Context) ApiWapiV3ApiTradingStatusHtmlGetRequest {
	return ApiWapiV3ApiTradingStatusHtmlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20020
 */
func (a *WalletApiService) WapiV3ApiTradingStatusHtmlGetExecute(r ApiWapiV3ApiTradingStatusHtmlGetRequest) (InlineResponse20020, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20020
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.WapiV3ApiTradingStatusHtmlGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wapi/v3/apiTradingStatus.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWapiV3AssetDetailHtmlGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiWapiV3AssetDetailHtmlGetRequest) Timestamp(timestamp int32) ApiWapiV3AssetDetailHtmlGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiWapiV3AssetDetailHtmlGetRequest) RecvWindow(recvWindow int32) ApiWapiV3AssetDetailHtmlGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiWapiV3AssetDetailHtmlGetRequest) Signature(signature string) ApiWapiV3AssetDetailHtmlGetRequest {
	r.signature = &signature
	return r
}

func (r ApiWapiV3AssetDetailHtmlGetRequest) Execute() (InlineResponse20024, *_nethttp.Response, error) {
	return r.ApiService.WapiV3AssetDetailHtmlGetExecute(r)
}

/*
 * WapiV3AssetDetailHtmlGet Asset Detail (USER_DATA)
 * Fetch details of assets supported on Binance.

Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWapiV3AssetDetailHtmlGetRequest
*/
func (a *WalletApiService) WapiV3AssetDetailHtmlGet(ctx _context.Context) ApiWapiV3AssetDetailHtmlGetRequest {
	return ApiWapiV3AssetDetailHtmlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20024
 */
func (a *WalletApiService) WapiV3AssetDetailHtmlGetExecute(r ApiWapiV3AssetDetailHtmlGetRequest) (InlineResponse20024, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20024
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.WapiV3AssetDetailHtmlGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wapi/v3/assetDetail.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWapiV3SystemStatusHtmlGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
}

func (r ApiWapiV3SystemStatusHtmlGetRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.WapiV3SystemStatusHtmlGetExecute(r)
}

/*
 * WapiV3SystemStatusHtmlGet System Status (System)
 * Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWapiV3SystemStatusHtmlGetRequest
 */
func (a *WalletApiService) WapiV3SystemStatusHtmlGet(ctx _context.Context) ApiWapiV3SystemStatusHtmlGetRequest {
	return ApiWapiV3SystemStatusHtmlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *WalletApiService) WapiV3SystemStatusHtmlGetExecute(r ApiWapiV3SystemStatusHtmlGetRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.WapiV3SystemStatusHtmlGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wapi/v3/systemStatus.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWapiV3TradeFeeHtmlGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	symbol     *string
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiWapiV3TradeFeeHtmlGetRequest) Symbol(symbol string) ApiWapiV3TradeFeeHtmlGetRequest {
	r.symbol = &symbol
	return r
}
func (r ApiWapiV3TradeFeeHtmlGetRequest) Timestamp(timestamp int32) ApiWapiV3TradeFeeHtmlGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiWapiV3TradeFeeHtmlGetRequest) RecvWindow(recvWindow int32) ApiWapiV3TradeFeeHtmlGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiWapiV3TradeFeeHtmlGetRequest) Signature(signature string) ApiWapiV3TradeFeeHtmlGetRequest {
	r.signature = &signature
	return r
}

func (r ApiWapiV3TradeFeeHtmlGetRequest) Execute() (InlineResponse20025, *_nethttp.Response, error) {
	return r.ApiService.WapiV3TradeFeeHtmlGetExecute(r)
}

/*
 * WapiV3TradeFeeHtmlGet Trade Fee (USER_DATA)
 * Fetch trade fee, values in percentage.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWapiV3TradeFeeHtmlGetRequest
*/
func (a *WalletApiService) WapiV3TradeFeeHtmlGet(ctx _context.Context) ApiWapiV3TradeFeeHtmlGetRequest {
	return ApiWapiV3TradeFeeHtmlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20025
 */
func (a *WalletApiService) WapiV3TradeFeeHtmlGetExecute(r ApiWapiV3TradeFeeHtmlGetRequest) (InlineResponse20025, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20025
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.WapiV3TradeFeeHtmlGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wapi/v3/tradeFee.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWapiV3UserAssetDribbletLogHtmlGetRequest struct {
	ctx        _context.Context
	ApiService WalletApi
	timestamp  *int32
	recvWindow *int32
	signature  *string
}

func (r ApiWapiV3UserAssetDribbletLogHtmlGetRequest) Timestamp(timestamp int32) ApiWapiV3UserAssetDribbletLogHtmlGetRequest {
	r.timestamp = &timestamp
	return r
}
func (r ApiWapiV3UserAssetDribbletLogHtmlGetRequest) RecvWindow(recvWindow int32) ApiWapiV3UserAssetDribbletLogHtmlGetRequest {
	r.recvWindow = &recvWindow
	return r
}
func (r ApiWapiV3UserAssetDribbletLogHtmlGetRequest) Signature(signature string) ApiWapiV3UserAssetDribbletLogHtmlGetRequest {
	r.signature = &signature
	return r
}

func (r ApiWapiV3UserAssetDribbletLogHtmlGetRequest) Execute() (InlineResponse20021, *_nethttp.Response, error) {
	return r.ApiService.WapiV3UserAssetDribbletLogHtmlGetExecute(r)
}

/*
 * WapiV3UserAssetDribbletLogHtmlGet DustLog (USER_DATA)
 * Fetch small amounts of assets exchanged BNB records.

Weight: 1
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiWapiV3UserAssetDribbletLogHtmlGetRequest
*/
func (a *WalletApiService) WapiV3UserAssetDribbletLogHtmlGet(ctx _context.Context) ApiWapiV3UserAssetDribbletLogHtmlGetRequest {
	return ApiWapiV3UserAssetDribbletLogHtmlGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse20021
 */
func (a *WalletApiService) WapiV3UserAssetDribbletLogHtmlGetExecute(r ApiWapiV3UserAssetDribbletLogHtmlGetRequest) (InlineResponse20021, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20021
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.WapiV3UserAssetDribbletLogHtmlGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/wapi/v3/userAssetDribbletLog.html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.timestamp != nil {
		localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	if r.signature != nil {
		localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
