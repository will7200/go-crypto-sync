/*
 * CoinBase API
 *
 * Coinbase provides a simple and powerful REST API to integrate bitcoin, bitcoin cash, litecoin and ethereum payments into your business or application.  This API reference provides information on available endpoints and how to interact with it. To read more about the API, visit our API documentation.
 *
 * API version: 2019-11-15
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package coinbase

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// AccountsApiService AccountsApi service
type AccountsApiService service

type ApiGetAccountRequest struct {
	ctx               _context.Context
	ApiService        *AccountsApiService
	accountId         string
	cBACCESSSIGN      *string
	cBACCESSTIMESTAMP *int32
}

// cBACCESSSIGN  The user generated message signature (see below) The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation).
func (r ApiGetAccountRequest) CBACCESSSIGN(cBACCESSSIGN string) ApiGetAccountRequest {
	r.cBACCESSSIGN = &cBACCESSSIGN
	return r
}

// cBACCESSTIMESTAMP  A timestamp for your request
func (r ApiGetAccountRequest) CBACCESSTIMESTAMP(cBACCESSTIMESTAMP int32) ApiGetAccountRequest {
	r.cBACCESSTIMESTAMP = &cBACCESSTIMESTAMP
	return r
}

func (r ApiGetAccountRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
 * GetAccount Retrieve Account
 * Show current user’s account. To access the primary account for a given currency, a currency string (BTC or ETH) can be used instead of the account id in the URL.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId The id of the account
 * @return ApiGetAccountRequest
 */
func (a *AccountsApiService) GetAccount(ctx _context.Context, accountId string) ApiGetAccountRequest {
	return ApiGetAccountRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

/*
 * Execute executes the request
 * @return Account
 */
func (a *AccountsApiService) GetAccountExecute(r ApiGetAccountRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{account_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", _neturl.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cBACCESSSIGN != nil {
		localVarHeaderParams["CB-ACCESS-SIGN"] = parameterToString(*r.cBACCESSSIGN, "")
	} else {
		localVarHeaderParams["CB-ACCESS-SIGN"] = "auto"
	}

	if r.cBACCESSTIMESTAMP != nil {
		localVarHeaderParams["CB-ACCESS-TIMESTAMP"] = parameterToString(*r.cBACCESSTIMESTAMP, "")
	} else {
		localVarHeaderParams["CB-ACCESS-TIMESTAMP"] = "auto"
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				key = apiKey.Key
				localVarHeaderParams["CB-ACCESS-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountsRequest struct {
	ctx               _context.Context
	ApiService        *AccountsApiService
	cBACCESSSIGN      *string
	cBACCESSTIMESTAMP *int32
	endingBefore      *string
	startingAfter     *string
	limit             *int32
	order             *string
	previousUri       *string
	nextUri           *string
}

// cBACCESSSIGN  The user generated message signature (see below) The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation).
func (r ApiListAccountsRequest) CBACCESSSIGN(cBACCESSSIGN string) ApiListAccountsRequest {
	r.cBACCESSSIGN = &cBACCESSSIGN
	return r
}

// cBACCESSTIMESTAMP  A timestamp for your request
func (r ApiListAccountsRequest) CBACCESSTIMESTAMP(cBACCESSTIMESTAMP int32) ApiListAccountsRequest {
	r.cBACCESSTIMESTAMP = &cBACCESSTIMESTAMP
	return r
}

// endingBefore
func (r ApiListAccountsRequest) EndingBefore(endingBefore string) ApiListAccountsRequest {
	r.endingBefore = &endingBefore
	return r
}

// startingAfter
func (r ApiListAccountsRequest) StartingAfter(startingAfter string) ApiListAccountsRequest {
	r.startingAfter = &startingAfter
	return r
}

// limit
func (r ApiListAccountsRequest) Limit(limit int32) ApiListAccountsRequest {
	r.limit = &limit
	return r
}

// order
func (r ApiListAccountsRequest) Order(order string) ApiListAccountsRequest {
	r.order = &order
	return r
}

// previousUri
func (r ApiListAccountsRequest) PreviousUri(previousUri string) ApiListAccountsRequest {
	r.previousUri = &previousUri
	return r
}

// nextUri
func (r ApiListAccountsRequest) NextUri(nextUri string) ApiListAccountsRequest {
	r.nextUri = &nextUri
	return r
}

func (r ApiListAccountsRequest) Execute() (InlineResponse200, *_nethttp.Response, error) {
	return r.ApiService.ListAccountsExecute(r)
}

/*
 * ListAccounts List Accounts
 * Lists current user’s accounts to which the authentication method has access to.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListAccountsRequest
 */
func (a *AccountsApiService) ListAccounts(ctx _context.Context) ApiListAccountsRequest {
	return ApiListAccountsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse200
 */
func (a *AccountsApiService) ListAccountsExecute(r ApiListAccountsRequest) (InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.ListAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.endingBefore != nil {
		localVarQueryParams.Add("ending_before", parameterToString(*r.endingBefore, ""))
	}
	if r.startingAfter != nil {
		localVarQueryParams.Add("starting_after", parameterToString(*r.startingAfter, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.previousUri != nil {
		localVarQueryParams.Add("previous_uri", parameterToString(*r.previousUri, ""))
	}
	if r.nextUri != nil {
		localVarQueryParams.Add("next_uri", parameterToString(*r.nextUri, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cBACCESSSIGN != nil {
		localVarHeaderParams["CB-ACCESS-SIGN"] = parameterToString(*r.cBACCESSSIGN, "")
	} else {
		localVarHeaderParams["CB-ACCESS-SIGN"] = "auto"
	}

	if r.cBACCESSTIMESTAMP != nil {
		localVarHeaderParams["CB-ACCESS-TIMESTAMP"] = parameterToString(*r.cBACCESSTIMESTAMP, "")
	} else {
		localVarHeaderParams["CB-ACCESS-TIMESTAMP"] = "auto"
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				key = apiKey.Key
				localVarHeaderParams["CB-ACCESS-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransactionsRequest struct {
	ctx               _context.Context
	ApiService        *AccountsApiService
	accountId         string
	cBACCESSSIGN      *string
	cBACCESSTIMESTAMP *int32
}

// cBACCESSSIGN  The user generated message signature (see below) The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using the secret key on the prehash string timestamp + method + requestPath + body (where + represents string concatenation).
func (r ApiListTransactionsRequest) CBACCESSSIGN(cBACCESSSIGN string) ApiListTransactionsRequest {
	r.cBACCESSSIGN = &cBACCESSSIGN
	return r
}

// cBACCESSTIMESTAMP  A timestamp for your request
func (r ApiListTransactionsRequest) CBACCESSTIMESTAMP(cBACCESSTIMESTAMP int32) ApiListTransactionsRequest {
	r.cBACCESSTIMESTAMP = &cBACCESSTIMESTAMP
	return r
}

func (r ApiListTransactionsRequest) Execute() (InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.ListTransactionsExecute(r)
}

/*
 * ListTransactions List transactions
 * Lists account’s transactions. See transaction resource for more information.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId The id of the account
 * @return ApiListTransactionsRequest
 */
func (a *AccountsApiService) ListTransactions(ctx _context.Context, accountId string) ApiListTransactionsRequest {
	return ApiListTransactionsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

/*
 * Execute executes the request
 * @return InlineResponse2001
 */
func (a *AccountsApiService) ListTransactionsExecute(r ApiListTransactionsRequest) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsApiService.ListTransactions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{account_id}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", _neturl.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.cBACCESSSIGN != nil {
		localVarHeaderParams["CB-ACCESS-SIGN"] = parameterToString(*r.cBACCESSSIGN, "")
	} else {
		localVarHeaderParams["CB-ACCESS-SIGN"] = "auto"
	}

	if r.cBACCESSTIMESTAMP != nil {
		localVarHeaderParams["CB-ACCESS-TIMESTAMP"] = parameterToString(*r.cBACCESSTIMESTAMP, "")
	} else {
		localVarHeaderParams["CB-ACCESS-TIMESTAMP"] = "auto"
	}

	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				key = apiKey.Key
				localVarHeaderParams["CB-ACCESS-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
