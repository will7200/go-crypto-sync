/*
 * Nomics Cryptocurrency & Bitcoin API
 *
 * # Introduction  Welcome to the Nomics Cryptocurrency & Bitcoin API. To sign up for an API key please [go here](https://p.nomics.com/cryptocurrency-bitcoin-api/).  [nomics.com](https://nomics.com) is built entirely with the Nomics API. Everything we've done on [nomics.com](https://nomics.com) you can do with our API. There are no internal API endpoints.  If you need support, reach out to use at our [forums](https://forums.nomics.com/).  # General  ## API Server URL  The Nomics API runs at `https://api.nomics.com/v1`. All requests should be prefixed by the server URL.  ## JSON and CSV Support  By default, all endpoints serve data as JSON. However, by passing `format=csv` in the URL, some endpoints will return CSV data. This can be used in Google Sheets via the `IMPORTDATA` function.  CSV responses will not contain a header row, this is so that data can be easily concatenated from multiple requests. The fields will be rendered in the same order as the JSON fields. See the endpoint's documentation for an example.  Not all endpoints support CSV. Endpoints that support CSV will have the `format` parameter in the parameters section.  ## Errors  The Nomics API uses standard HTTP status codes to indicate success or failure. 200 represents success, 4xx represents a user error (such as a problem with your key), and 5xx represents a problem with our API.  ## Versioning  We follow Semantic Versioning. That means our API is versioned as Major.Minor.Patch. For example, Version 1.2.3 has major version 1, minor version 2, and patch version 3.  Major version changes indicate that we have altered the API significantly and it is no longer compatible with a previous version. Major versions are also used as the API URL prefix.  When we update the major version, we will not remove the previous version without notice to API customers and a deprecation period to allow everyone to smoothly update to the new version.  Minor version changes indicate that we have added new functionality without breaking any existing functionality. An API client is compatible with future minor versions. Note that a minor version update may add a new field to an existing API endpoint's response. Your API client must ignore fields it does not understand in order to be compatible with future minor versions.  Patch version changes indicate we fixed a bug or security vulnerability. Patch versions don't add new functionality.  ## Cross Origin Resource Sharing (CORS)  This API supports Cross Origin Resource Sharing, which allows you to make API requests directly from your user's browser.  To use CORS, you must provide Nomics with the domains on which your application will run so that we can whitelist them for CORS access.  Requests from `localhost`, `127.0.0.1`, and `0.0.0.0` will always succeed to aid in development.  ## Demo Application  A demo application using the Nomics API, CORS, and React is available on Glitch.com. This can help you get started using the Nomics API. Keep in mind it uses the demo key, which is rotated frequently. You should get your own API key before deploying an app to production. Check it out:  <div class=\"glitch-embed-wrap\" style=\"height: 420px; width: 100%;\">   <iframe src=\"https://glitch.com/embed/#!/embed/nomics-api-demo?path=README.md\" alt=\"nomics-api-demo on glitch\" style=\"height: 100%; width: 100%; border: 0;\"></iframe> </div>  ## Demo Spreadsheet  Here is a demo of using the Nomics API with Google Sheets.  <iframe width=\"100%\" height=\"400px\" src=\"https://docs.google.com/spreadsheets/d/e/2PACX-1vShn2iWjvqQ0ueBa9l9g1UBYVM92OZSgZ4nmp0rWuykvHPrvyMyMeSN4r0Orj0ACEIIKdCz6cc5abCw/pubhtml?widget=true&amp;headers=false\"></iframe>  ### Formulas  * A2: `=IMPORTDATA(\"https://api.nomics.com/v1/prices?key=your-key-here&format=csv\")` * Column F: `=LOOKUP(D2,A:A,B:B)` finds D2 (BTC) in column A and pulls the price from column B * Column G: `=E2*F2` * Column H: `=G2/I$2` * Column I: `=SUM(G:G)`  # SDKs and Libraries  ## By Nomics - [Nomics JavaScript Client](https://github.com/nomics-crypto/nomics-javascript)  ## Community Submissions - [Nomics.com Swift SDK](https://forums.nomics.com/t/swift-sdk-supporting-ios-macos-tvos-and-watchos/) by Nick DiZazzo - [Nomics Node.js Library](https://forums.nomics.com/t/i-made-a-library-for-node-js/) by mikunimaru - [Nomics Python Wrapper](https://forums.nomics.com/t/python-package-for-nomics-api/119) by Taylor Facen - [Python Wrapper for Nomics](https://github.com/AviFelman/py-nomics) by Avi Felman  We love watching developers explore new use-cases with our API. Whether you're tinkering on a small side project or building an open-source resource, please share what you're up to in our [forums](https://forums.nomics.com/).  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package nomics

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// CandlesApiService CandlesApi service
type CandlesApiService service

type ApiGetCandlesRequest struct {
	ctx        _context.Context
	ApiService *CandlesApiService
	interval   *string
	currency   *string
	start      *string
	end        *string
	format     *string
}

// interval  Time interval of the candle
func (r ApiGetCandlesRequest) Interval(interval string) ApiGetCandlesRequest {
	r.interval = &interval
	return r
}

// currency  Currency ID
func (r ApiGetCandlesRequest) Currency(currency string) ApiGetCandlesRequest {
	r.currency = &currency
	return r
}

// start  Start time of the interval in RFC3339 (URI escaped). If not provided, starts from the first candle for daily candles and from the current time minus 30 days for hourly candles.
func (r ApiGetCandlesRequest) Start(start string) ApiGetCandlesRequest {
	r.start = &start
	return r
}

// end  End time of the interval in RFC3339 (URI escaped). If not provided, the current time is used except for when hourly candles with a `start` time older than 30 days are requested.  In that case, the `end` time defaults to the `start` time plus 7 days.
func (r ApiGetCandlesRequest) End(end string) ApiGetCandlesRequest {
	r.end = &end
	return r
}

// format  Format of the response. Defaults to JSON when blank.
func (r ApiGetCandlesRequest) Format(format string) ApiGetCandlesRequest {
	r.format = &format
	return r
}

func (r ApiGetCandlesRequest) Execute() ([]InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.GetCandlesExecute(r)
}

/*
 * GetCandles Aggregated OHLCV Candles
 * ### !! This API endpoint is only available to customers of our paid API plans.  Please [go here](https://p.nomics.com/pricing/) to learn more.

The candles endpoint returns aggregated open, high, low, close, and volume information for Nomics currencies.
When asking for candles, a currency is provided as a parameter. Nomics aggregates all markets where the given
currency is the base currency and the quote currency is a fiat currency, BTC, or ETH and returns all values in
USD.

Candles are aggregated across all markets for the base currencies, which necessitates converting to a common
quote currency. Nomics converts all markets into USD in order to aggregated candles.

Candles have the following time range limits based on interval and time:

* `1d`: Available from inception with no range limit
* `1h`: Available from inception. Time range limits:
  * Past 30 days: accessible in a single request
  * Older than 30 days: 7 days at a time

CSV format is: `timestamp,open,high,low,close,volume,empty,transparent_open,transparent_high,transparent_low,transparent_close,transparent_volume`

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCandlesRequest
*/
func (a *CandlesApiService) GetCandles(ctx _context.Context) ApiGetCandlesRequest {
	return ApiGetCandlesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse20015
 */
func (a *CandlesApiService) GetCandlesExecute(r ApiGetCandlesRequest) ([]InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CandlesApiService.GetCandles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}

	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExchangeCandlesRequest struct {
	ctx        _context.Context
	ApiService *CandlesApiService
	interval   *string
	exchange   *string
	market     *string
	start      *string
	end        *string
	format     *string
}

// interval  Time interval of the candle
func (r ApiGetExchangeCandlesRequest) Interval(interval string) ApiGetExchangeCandlesRequest {
	r.interval = &interval
	return r
}

// exchange  Exchange ID
func (r ApiGetExchangeCandlesRequest) Exchange(exchange string) ApiGetExchangeCandlesRequest {
	r.exchange = &exchange
	return r
}

// market  The Exchange's Market ID from [Markets](#tag/Markets)
func (r ApiGetExchangeCandlesRequest) Market(market string) ApiGetExchangeCandlesRequest {
	r.market = &market
	return r
}

// start  Start time of the interval in RFC3339 (URI escaped).  If not provided, then candles will be returned starting from the current time minus the date range limit for the requested interval.  For example, if you request hourly candles without specifying a start time, then candles spanning the last 30 days will be returned.
func (r ApiGetExchangeCandlesRequest) Start(start string) ApiGetExchangeCandlesRequest {
	r.start = &start
	return r
}

// end  End time of the interval in RFC3339 (URI escaped). If not provided, the current time is used.
func (r ApiGetExchangeCandlesRequest) End(end string) ApiGetExchangeCandlesRequest {
	r.end = &end
	return r
}

// format  Format of the response. Defaults to JSON when blank.
func (r ApiGetExchangeCandlesRequest) Format(format string) ApiGetExchangeCandlesRequest {
	r.format = &format
	return r
}

func (r ApiGetExchangeCandlesRequest) Execute() ([]InlineResponse20019, *_nethttp.Response, error) {
	return r.ApiService.GetExchangeCandlesExecute(r)
}

/*
 * GetExchangeCandles Exchange OHLCV Candles
 * ### !! This API endpoint is only available to customers of our paid API plans.  Please [go here](https://p.nomics.com/pricing/) to learn more.

The exchange candles endpoint returns raw open, close, high, low, and volume information for Nomics Markets.
The data is not aggregated, therefore prices are in the quote currency of the market and volume is in the base
currency of the market.

History is available for all candle sizes from inception, but
there are limits on the length of the date range you can
request at a time:

| interval | limit per request |
|----------|-------------------|
| `1d`     | no limit          |
| `4h`     | 120 days          |
| `1h`     | 30 days           |
| `30m`    | 14 days           |
| `5m`     | 3 days            |
| `1m`     | 1 day             |

If the difference between your `end` and `start` parameters
for the `interval` you're requesting exceeds the limit, then
you'll receive an error.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetExchangeCandlesRequest
*/
func (a *CandlesApiService) GetExchangeCandles(ctx _context.Context) ApiGetExchangeCandlesRequest {
	return ApiGetExchangeCandlesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse20019
 */
func (a *CandlesApiService) GetExchangeCandlesExecute(r ApiGetExchangeCandlesRequest) ([]InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20019
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CandlesApiService.GetExchangeCandles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/exchange_candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.exchange == nil {
		return localVarReturnValue, nil, reportError("exchange is required and must be specified")
	}
	if r.market == nil {
		return localVarReturnValue, nil, reportError("market is required and must be specified")
	}

	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	localVarQueryParams.Add("exchange", parameterToString(*r.exchange, ""))
	localVarQueryParams.Add("market", parameterToString(*r.market, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketCandlesRequest struct {
	ctx        _context.Context
	ApiService *CandlesApiService
	interval   *string
	base       *string
	quote      *string
	start      *string
	end        *string
	format     *string
}

// interval  Time interval of the candle
func (r ApiGetMarketCandlesRequest) Interval(interval string) ApiGetMarketCandlesRequest {
	r.interval = &interval
	return r
}

// base  Base currency of the pair
func (r ApiGetMarketCandlesRequest) Base(base string) ApiGetMarketCandlesRequest {
	r.base = &base
	return r
}

// quote  Quote currency of the pair
func (r ApiGetMarketCandlesRequest) Quote(quote string) ApiGetMarketCandlesRequest {
	r.quote = &quote
	return r
}

// start  Start time of the interval in RFC3339 (URI escaped).  If not provided, then candles will be returned starting from the current time minus the date range limit for the requested interval.  For example, if you request hourly candles without specifying a start time, then candles spanning the last 30 days will be returned.
func (r ApiGetMarketCandlesRequest) Start(start string) ApiGetMarketCandlesRequest {
	r.start = &start
	return r
}

// end  End time of the interval in RFC3339 (URI escaped). If not provided, the current time is used.
func (r ApiGetMarketCandlesRequest) End(end string) ApiGetMarketCandlesRequest {
	r.end = &end
	return r
}

// format  Format of the response. Defaults to JSON when blank.
func (r ApiGetMarketCandlesRequest) Format(format string) ApiGetMarketCandlesRequest {
	r.format = &format
	return r
}

func (r ApiGetMarketCandlesRequest) Execute() ([]InlineResponse20020, *_nethttp.Response, error) {
	return r.ApiService.GetMarketCandlesExecute(r)
}

/*
 * GetMarketCandles Aggregated Pair OHLCV Candles
 * ### !! This API endpoint is only available to customers of our paid API plans.  Please [go here](https://p.nomics.com/pricing/) to learn more.

The Aggregated Pair Candles endpoint returns aggregated open, close, high, low, and volume information for an
Aggregated Pair of base and quote currencies. Open and Close are volume weighted averages across markets, while
High and Low are the max and min prices across markets. Volume is the total volume.

This is equivalent to getting Exchange Market OHLCV Candles across all exchanges with the given base and quote
and merging them together. This is different from Aggregated OHLCV Candles because those convert to USD and
merge candles across the base currency only.

The data is aggregated but not converted to USD, so OHLC values are in the quote currency unit and Volume
is in the base currency unit.

History is available for all candle sizes from inception, but
there are limits on the length of the date range you can
request at a time:

| interval | limit    |
|----------|----------|
| `1d`     | no limit |
| `4h`     | 120 days |
| `1h`     | 30 days  |
| `30m`    | 14 days  |
| `5m`     | 3 days   |
| `1m`     | 1 day    |

If the difference between your `end` and `start` parameters
for the `interval` you're requesting exceeds the limit, then
you'll receive an error.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetMarketCandlesRequest
*/
func (a *CandlesApiService) GetMarketCandles(ctx _context.Context) ApiGetMarketCandlesRequest {
	return ApiGetMarketCandlesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse20020
 */
func (a *CandlesApiService) GetMarketCandlesExecute(r ApiGetMarketCandlesRequest) ([]InlineResponse20020, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20020
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CandlesApiService.GetMarketCandles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markets/candles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.interval == nil {
		return localVarReturnValue, nil, reportError("interval is required and must be specified")
	}
	if r.base == nil {
		return localVarReturnValue, nil, reportError("base is required and must be specified")
	}
	if r.quote == nil {
		return localVarReturnValue, nil, reportError("quote is required and must be specified")
	}

	localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	localVarQueryParams.Add("base", parameterToString(*r.base, ""))
	localVarQueryParams.Add("quote", parameterToString(*r.quote, ""))
	if r.start != nil {
		localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	}
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
