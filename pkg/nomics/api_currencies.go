/*
 * Nomics Cryptocurrency & Bitcoin API
 *
 * # Introduction  Welcome to the Nomics Cryptocurrency & Bitcoin API. To sign up for an API key please [go here](https://p.nomics.com/cryptocurrency-bitcoin-api/).  [nomics.com](https://nomics.com) is built entirely with the Nomics API. Everything we've done on [nomics.com](https://nomics.com) you can do with our API. There are no internal API endpoints.  If you need support, reach out to use at our [forums](https://forums.nomics.com/).  # General  ## API Server URL  The Nomics API runs at `https://api.nomics.com/v1`. All requests should be prefixed by the server URL.  ## JSON and CSV Support  By default, all endpoints serve data as JSON. However, by passing `format=csv` in the URL, some endpoints will return CSV data. This can be used in Google Sheets via the `IMPORTDATA` function.  CSV responses will not contain a header row, this is so that data can be easily concatenated from multiple requests. The fields will be rendered in the same order as the JSON fields. See the endpoint's documentation for an example.  Not all endpoints support CSV. Endpoints that support CSV will have the `format` parameter in the parameters section.  ## Errors  The Nomics API uses standard HTTP status codes to indicate success or failure. 200 represents success, 4xx represents a user error (such as a problem with your key), and 5xx represents a problem with our API.  ## Versioning  We follow Semantic Versioning. That means our API is versioned as Major.Minor.Patch. For example, Version 1.2.3 has major version 1, minor version 2, and patch version 3.  Major version changes indicate that we have altered the API significantly and it is no longer compatible with a previous version. Major versions are also used as the API URL prefix.  When we update the major version, we will not remove the previous version without notice to API customers and a deprecation period to allow everyone to smoothly update to the new version.  Minor version changes indicate that we have added new functionality without breaking any existing functionality. An API client is compatible with future minor versions. Note that a minor version update may add a new field to an existing API endpoint's response. Your API client must ignore fields it does not understand in order to be compatible with future minor versions.  Patch version changes indicate we fixed a bug or security vulnerability. Patch versions don't add new functionality.  ## Cross Origin Resource Sharing (CORS)  This API supports Cross Origin Resource Sharing, which allows you to make API requests directly from your user's browser.  To use CORS, you must provide Nomics with the domains on which your application will run so that we can whitelist them for CORS access.  Requests from `localhost`, `127.0.0.1`, and `0.0.0.0` will always succeed to aid in development.  ## Demo Application  A demo application using the Nomics API, CORS, and React is available on Glitch.com. This can help you get started using the Nomics API. Keep in mind it uses the demo key, which is rotated frequently. You should get your own API key before deploying an app to production. Check it out:  <div class=\"glitch-embed-wrap\" style=\"height: 420px; width: 100%;\">   <iframe src=\"https://glitch.com/embed/#!/embed/nomics-api-demo?path=README.md\" alt=\"nomics-api-demo on glitch\" style=\"height: 100%; width: 100%; border: 0;\"></iframe> </div>  ## Demo Spreadsheet  Here is a demo of using the Nomics API with Google Sheets.  <iframe width=\"100%\" height=\"400px\" src=\"https://docs.google.com/spreadsheets/d/e/2PACX-1vShn2iWjvqQ0ueBa9l9g1UBYVM92OZSgZ4nmp0rWuykvHPrvyMyMeSN4r0Orj0ACEIIKdCz6cc5abCw/pubhtml?widget=true&amp;headers=false\"></iframe>  ### Formulas  * A2: `=IMPORTDATA(\"https://api.nomics.com/v1/prices?key=your-key-here&format=csv\")` * Column F: `=LOOKUP(D2,A:A,B:B)` finds D2 (BTC) in column A and pulls the price from column B * Column G: `=E2*F2` * Column H: `=G2/I$2` * Column I: `=SUM(G:G)`  # SDKs and Libraries  ## By Nomics - [Nomics JavaScript Client](https://github.com/nomics-crypto/nomics-javascript)  ## Community Submissions - [Nomics.com Swift SDK](https://forums.nomics.com/t/swift-sdk-supporting-ios-macos-tvos-and-watchos/) by Nick DiZazzo - [Nomics Node.js Library](https://forums.nomics.com/t/i-made-a-library-for-node-js/) by mikunimaru - [Nomics Python Wrapper](https://forums.nomics.com/t/python-package-for-nomics-api/119) by Taylor Facen - [Python Wrapper for Nomics](https://github.com/AviFelman/py-nomics) by Avi Felman  We love watching developers explore new use-cases with our API. Whether you're tinkering on a small side project or building an open-source resource, please share what you're up to in our [forums](https://forums.nomics.com/).  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package nomics

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// CurrenciesApiService CurrenciesApi service
type CurrenciesApiService service

type ApiGetCurrenciesRequest struct {
	ctx        _context.Context
	ApiService *CurrenciesApiService
	ids        *string
	attributes *string
	format     *string
}

// ids  Comma separated list of Nomics Currency IDs to filter result rows
func (r ApiGetCurrenciesRequest) Ids(ids string) ApiGetCurrenciesRequest {
	r.ids = &ids
	return r
}

// attributes  Comma separated list of currency attributes to filter result columns
func (r ApiGetCurrenciesRequest) Attributes(attributes string) ApiGetCurrenciesRequest {
	r.attributes = &attributes
	return r
}

// format  Format of the response. Defaults to JSON when blank.
func (r ApiGetCurrenciesRequest) Format(format string) ApiGetCurrenciesRequest {
	r.format = &format
	return r
}

func (r ApiGetCurrenciesRequest) Execute() ([]InlineResponse2001, *_nethttp.Response, error) {
	return r.ApiService.GetCurrenciesExecute(r)
}

/*
 * GetCurrencies Currencies Metadata
 * The currencies endpoint returns all the currencies and their metadata that Nomics supports.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCurrenciesRequest
 */
func (a *CurrenciesApiService) GetCurrencies(ctx _context.Context) ApiGetCurrenciesRequest {
	return ApiGetCurrenciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse2001
 */
func (a *CurrenciesApiService) GetCurrenciesExecute(r ApiGetCurrenciesRequest) ([]InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2001
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrencies")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.attributes != nil {
		localVarQueryParams.Add("attributes", parameterToString(*r.attributes, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesSparklineRequest struct {
	ctx        _context.Context
	ApiService *CurrenciesApiService
	start      *string
	ids        *string
	end        *string
	convert    *string
}

// start  Start time of the interval in RFC3339 (URI escaped)
func (r ApiGetCurrenciesSparklineRequest) Start(start string) ApiGetCurrenciesSparklineRequest {
	r.start = &start
	return r
}

// ids  Comma separated list of Nomics Currency IDs to filter result rows
func (r ApiGetCurrenciesSparklineRequest) Ids(ids string) ApiGetCurrenciesSparklineRequest {
	r.ids = &ids
	return r
}

// end  End time of the interval in RFC3339 (URI escaped). If not provided, the current time is used.
func (r ApiGetCurrenciesSparklineRequest) End(end string) ApiGetCurrenciesSparklineRequest {
	r.end = &end
	return r
}

// convert  Currency to quote ticker price, market cap, and volume values. May be a Fiat Currency or Cryptocurrency. Default is `USD`.
func (r ApiGetCurrenciesSparklineRequest) Convert(convert string) ApiGetCurrenciesSparklineRequest {
	r.convert = &convert
	return r
}

func (r ApiGetCurrenciesSparklineRequest) Execute() ([]InlineResponse2002, *_nethttp.Response, error) {
	return r.ApiService.GetCurrenciesSparklineExecute(r)
}

/*
 * GetCurrenciesSparkline Currencies Sparkline
 * The currencies sparkline endpoint returns prices for all currencies within a customizable time interval
suitable for sparkline charts.

**Note** the timestamps and prices are built off of OHLCV candles using the close price. This means that the timestamp
represents the start of the candle, and the price is the close price of that candle. This means the response's final timestamp
and price value are always as current as possible, but also that the price is effectively "off" by one candle. This endpoint
is designed to serve as a convenient way to render sparklines, if you need exactly aligned times and prices you can use the
[Aggregated OHLCV Candles endpoint](#operation/getCandles).

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCurrenciesSparklineRequest
*/
func (a *CurrenciesApiService) GetCurrenciesSparkline(ctx _context.Context) ApiGetCurrenciesSparklineRequest {
	return ApiGetCurrenciesSparklineRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse2002
 */
func (a *CurrenciesApiService) GetCurrenciesSparklineExecute(r ApiGetCurrenciesSparklineRequest) ([]InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2002
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrenciesSparkline")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencies/sparkline"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}

	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.convert != nil {
		localVarQueryParams.Add("convert", parameterToString(*r.convert, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrenciesTickerRequest struct {
	ctx                 _context.Context
	ApiService          *CurrenciesApiService
	ids                 *string
	interval            *string
	quoteCurrency       *string
	convert             *string
	status              *string
	filter              *string
	sort                *string
	includeTransparency *bool
	perPage             *int32
	page                *int32
}

// ids  Comma separated list of Nomics Currency IDs to filter result rows
func (r ApiGetCurrenciesTickerRequest) Ids(ids string) ApiGetCurrenciesTickerRequest {
	r.ids = &ids
	return r
}

// interval  Comma separated time interval of the ticker(s). Default is `1d,7d,30d,365d,ytd`.
func (r ApiGetCurrenciesTickerRequest) Interval(interval string) ApiGetCurrenciesTickerRequest {
	r.interval = &interval
	return r
}

// quoteCurrency  Currency to quote ticker price, market cap, and volume values. Must be a valid currency from [Exchange Rates](#operation/getExchangeRates). Default is `USD`.
func (r ApiGetCurrenciesTickerRequest) QuoteCurrency(quoteCurrency string) ApiGetCurrenciesTickerRequest {
	r.quoteCurrency = &quoteCurrency
	return r
}

// convert  Currency to quote ticker price, market cap, and volume values. May be a Fiat Currency or Cryptocurrency. Default is `USD`.
func (r ApiGetCurrenciesTickerRequest) Convert(convert string) ApiGetCurrenciesTickerRequest {
	r.convert = &convert
	return r
}

// status  Status by which to filter currencies. If not provided, all currencies are shown.
func (r ApiGetCurrenciesTickerRequest) Status(status string) ApiGetCurrenciesTickerRequest {
	r.status = &status
	return r
}

// filter  Further filter the set of currencies.  The `new` filter returns currencies that have recently been priced by Nomics and `any` returns currencies regardless of their state.  The `any` filer may be used to retrieve new-but-stale currencies that are listed under `new`, but are no longer active.
func (r ApiGetCurrenciesTickerRequest) Filter(filter string) ApiGetCurrenciesTickerRequest {
	r.filter = &filter
	return r
}

// sort  How to sort the returned currencies.  `rank` sorts by rank ascending and `first_priced_at` sorts by when each currency was first priced by Nomics descending.
func (r ApiGetCurrenciesTickerRequest) Sort(sort string) ApiGetCurrenciesTickerRequest {
	r.sort = &sort
	return r
}

// includeTransparency  Whether to include [Transparent Volume](https://blog.nomics.com/essays/transparent-volume/) and transparent market cap information in the response. Default is `false`. This option is only available to customers of our paid API plans.
func (r ApiGetCurrenciesTickerRequest) IncludeTransparency(includeTransparency bool) ApiGetCurrenciesTickerRequest {
	r.includeTransparency = &includeTransparency
	return r
}

// perPage  The maximum number of items to return per paginated response. Paginated responses include an additional response header, `X-Pagination-Total-Items`, which represents the total number of items available after all the request filters have been applied.  Must be between `1` and `100` (inclusive).
func (r ApiGetCurrenciesTickerRequest) PerPage(perPage int32) ApiGetCurrenciesTickerRequest {
	r.perPage = &perPage
	return r
}

// page  Which page of items to get.  Only applicable when `per-page` is also supplied.
func (r ApiGetCurrenciesTickerRequest) Page(page int32) ApiGetCurrenciesTickerRequest {
	r.page = &page
	return r
}

func (r ApiGetCurrenciesTickerRequest) Execute() ([]InlineResponse200, *_nethttp.Response, error) {
	return r.ApiService.GetCurrenciesTickerExecute(r)
}

/*
 * GetCurrenciesTicker Currencies Ticker
 * Price, volume, market cap, and rank for all currencies across 1 hour, 1 day, 7 day, 30 day, 365 day, and year to date intervals. Current prices are updated every 10 seconds.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetCurrenciesTickerRequest
 */
func (a *CurrenciesApiService) GetCurrenciesTicker(ctx _context.Context) ApiGetCurrenciesTickerRequest {
	return ApiGetCurrenciesTickerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse200
 */
func (a *CurrenciesApiService) GetCurrenciesTickerExecute(r ApiGetCurrenciesTickerRequest) ([]InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetCurrenciesTicker")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/currencies/ticker"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.ids != nil {
		localVarQueryParams.Add("ids", parameterToString(*r.ids, ""))
	}
	if r.interval != nil {
		localVarQueryParams.Add("interval", parameterToString(*r.interval, ""))
	}
	if r.quoteCurrency != nil {
		localVarQueryParams.Add("quote-currency", parameterToString(*r.quoteCurrency, ""))
	}
	if r.convert != nil {
		localVarQueryParams.Add("convert", parameterToString(*r.convert, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.includeTransparency != nil {
		localVarQueryParams.Add("include-transparency", parameterToString(*r.includeTransparency, ""))
	}
	if r.perPage != nil {
		localVarQueryParams.Add("per-page", parameterToString(*r.perPage, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSupplyHistoryRequest struct {
	ctx        _context.Context
	ApiService *CurrenciesApiService
	currency   *string
	start      *string
	end        *string
	format     *string
}

// currency  Currency ID
func (r ApiGetSupplyHistoryRequest) Currency(currency string) ApiGetSupplyHistoryRequest {
	r.currency = &currency
	return r
}

// start  Start time of the interval in RFC3339 (URI escaped)
func (r ApiGetSupplyHistoryRequest) Start(start string) ApiGetSupplyHistoryRequest {
	r.start = &start
	return r
}

// end  End time of the interval in RFC3339 (URI escaped). If not provided, the current time is used.
func (r ApiGetSupplyHistoryRequest) End(end string) ApiGetSupplyHistoryRequest {
	r.end = &end
	return r
}

// format  Format of the response. Defaults to JSON when blank.
func (r ApiGetSupplyHistoryRequest) Format(format string) ApiGetSupplyHistoryRequest {
	r.format = &format
	return r
}

func (r ApiGetSupplyHistoryRequest) Execute() ([]InlineResponse2004, *_nethttp.Response, error) {
	return r.ApiService.GetSupplyHistoryExecute(r)
}

/*
 * GetSupplyHistory Supply History
 * ### !! This API endpoint is only available to customers of our paid API plans.  Please [go here](https://p.nomics.com/pricing/) to learn more.

Supply history per currency for every day in a time range.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiGetSupplyHistoryRequest
*/
func (a *CurrenciesApiService) GetSupplyHistory(ctx _context.Context) ApiGetSupplyHistoryRequest {
	return ApiGetSupplyHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

/*
 * Execute executes the request
 * @return []InlineResponse2004
 */
func (a *CurrenciesApiService) GetSupplyHistoryExecute(r ApiGetSupplyHistoryRequest) ([]InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurrenciesApiService.GetSupplyHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/supplies/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.currency == nil {
		return localVarReturnValue, nil, reportError("currency is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}

	localVarQueryParams.Add("currency", parameterToString(*r.currency, ""))
	localVarQueryParams.Add("start", parameterToString(*r.start, ""))
	if r.end != nil {
		localVarQueryParams.Add("end", parameterToString(*r.end, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Key"]; ok {
				var key string
				key = apiKey.Key
				localVarQueryParams.Add("key", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
