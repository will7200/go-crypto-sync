/*
 * Nomics Cryptocurrency & Bitcoin API
 *
 * # Introduction  Welcome to the Nomics Cryptocurrency & Bitcoin API. To sign up for an API key please [go here](https://p.nomics.com/cryptocurrency-bitcoin-api/).  [nomics.com](https://nomics.com) is built entirely with the Nomics API. Everything we've done on [nomics.com](https://nomics.com) you can do with our API. There are no internal API endpoints.  If you need support, reach out to use at our [forums](https://forums.nomics.com/).  # General  ## API Server URL  The Nomics API runs at `https://api.nomics.com/v1`. All requests should be prefixed by the server URL.  ## JSON and CSV Support  By default, all endpoints serve data as JSON. However, by passing `format=csv` in the URL, some endpoints will return CSV data. This can be used in Google Sheets via the `IMPORTDATA` function.  CSV responses will not contain a header row, this is so that data can be easily concatenated from multiple requests. The fields will be rendered in the same order as the JSON fields. See the endpoint's documentation for an example.  Not all endpoints support CSV. Endpoints that support CSV will have the `format` parameter in the parameters section.  ## Errors  The Nomics API uses standard HTTP status codes to indicate success or failure. 200 represents success, 4xx represents a user error (such as a problem with your key), and 5xx represents a problem with our API.  ## Versioning  We follow Semantic Versioning. That means our API is versioned as Major.Minor.Patch. For example, Version 1.2.3 has major version 1, minor version 2, and patch version 3.  Major version changes indicate that we have altered the API significantly and it is no longer compatible with a previous version. Major versions are also used as the API URL prefix.  When we update the major version, we will not remove the previous version without notice to API customers and a deprecation period to allow everyone to smoothly update to the new version.  Minor version changes indicate that we have added new functionality without breaking any existing functionality. An API client is compatible with future minor versions. Note that a minor version update may add a new field to an existing API endpoint's response. Your API client must ignore fields it does not understand in order to be compatible with future minor versions.  Patch version changes indicate we fixed a bug or security vulnerability. Patch versions don't add new functionality.  ## Cross Origin Resource Sharing (CORS)  This API supports Cross Origin Resource Sharing, which allows you to make API requests directly from your user's browser.  To use CORS, you must provide Nomics with the domains on which your application will run so that we can whitelist them for CORS access.  Requests from `localhost`, `127.0.0.1`, and `0.0.0.0` will always succeed to aid in development.  ## Demo Application  A demo application using the Nomics API, CORS, and React is available on Glitch.com. This can help you get started using the Nomics API. Keep in mind it uses the demo key, which is rotated frequently. You should get your own API key before deploying an app to production. Check it out:  <div class=\"glitch-embed-wrap\" style=\"height: 420px; width: 100%;\">   <iframe src=\"https://glitch.com/embed/#!/embed/nomics-api-demo?path=README.md\" alt=\"nomics-api-demo on glitch\" style=\"height: 100%; width: 100%; border: 0;\"></iframe> </div>  ## Demo Spreadsheet  Here is a demo of using the Nomics API with Google Sheets.  <iframe width=\"100%\" height=\"400px\" src=\"https://docs.google.com/spreadsheets/d/e/2PACX-1vShn2iWjvqQ0ueBa9l9g1UBYVM92OZSgZ4nmp0rWuykvHPrvyMyMeSN4r0Orj0ACEIIKdCz6cc5abCw/pubhtml?widget=true&amp;headers=false\"></iframe>  ### Formulas  * A2: `=IMPORTDATA(\"https://api.nomics.com/v1/prices?key=your-key-here&format=csv\")` * Column F: `=LOOKUP(D2,A:A,B:B)` finds D2 (BTC) in column A and pulls the price from column B * Column G: `=E2*F2` * Column H: `=G2/I$2` * Column I: `=SUM(G:G)`  # SDKs and Libraries  ## By Nomics - [Nomics JavaScript Client](https://github.com/nomics-crypto/nomics-javascript)  ## Community Submissions - [Nomics.com Swift SDK](https://forums.nomics.com/t/swift-sdk-supporting-ios-macos-tvos-and-watchos/) by Nick DiZazzo - [Nomics Node.js Library](https://forums.nomics.com/t/i-made-a-library-for-node-js/) by mikunimaru - [Nomics Python Wrapper](https://forums.nomics.com/t/python-package-for-nomics-api/119) by Taylor Facen - [Python Wrapper for Nomics](https://github.com/AviFelman/py-nomics) by Avi Felman  We love watching developers explore new use-cases with our API. Whether you're tinkering on a small side project or building an open-source resource, please share what you're up to in our [forums](https://forums.nomics.com/).  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package nomics

import (
	"encoding/json"
)

// InlineResponse2003 struct for InlineResponse2003
type InlineResponse2003 struct {
	// The total number of currencies
	NumCurrencies *string `json:"num_currencies,omitempty"`
	// The total number of active currencies
	NumCurrenciesActive *string `json:"num_currencies_active,omitempty"`
	// The total number of inactive currencies
	NumCurrenciesInative *string `json:"num_currencies_inative,omitempty"`
	// The total number of dead currencies
	NumCurrenciesDead *string `json:"num_currencies_dead,omitempty"`
	// The total number of new currencies
	NumCurrenciesNew *string `json:"num_currencies_new,omitempty"`
	// Current global market cap
	MarketCap *string `json:"market_cap,omitempty"`
	// Current global transparent market cap
	TransparentMarketCap *string               `json:"transparent_market_cap,omitempty"`
	Var1d                *GlobalTickerInterval `json:"1d,omitempty"`
	Var7d                *GlobalTickerInterval `json:"7d,omitempty"`
	Var30d               *GlobalTickerInterval `json:"30d,omitempty"`
	Var365d              *GlobalTickerInterval `json:"365d,omitempty"`
	Ytd                  *GlobalTickerInterval `json:"ytd,omitempty"`
}

// NewInlineResponse2003 instantiates a new InlineResponse2003 object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewInlineResponse2003() *InlineResponse2003 {
	this := InlineResponse2003{}
	return &this
}

// NewInlineResponse2003WithDefaults instantiates a new InlineResponse2003 object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewInlineResponse2003WithDefaults() *InlineResponse2003 {
	this := InlineResponse2003{}
	return &this
}

// GetNumCurrencies returns the NumCurrencies field value if set, zero value otherwise.
func (o *InlineResponse2003) GetNumCurrencies() string {
	if o == nil || o.NumCurrencies == nil {
		var ret string
		return ret
	}
	return *o.NumCurrencies
}

// GetNumCurrenciesOk returns a tuple with the NumCurrencies field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetNumCurrenciesOk() (*string, bool) {
	if o == nil || o.NumCurrencies == nil {
		return nil, false
	}
	return o.NumCurrencies, true
}

// HasNumCurrencies returns a boolean if a field has been set.
func (o *InlineResponse2003) HasNumCurrencies() bool {
	if o != nil && o.NumCurrencies != nil {
		return true
	}

	return false
}

// SetNumCurrencies gets a reference to the given string and assigns it to the NumCurrencies field.
func (o *InlineResponse2003) SetNumCurrencies(v string) {
	o.NumCurrencies = &v
}

// GetNumCurrenciesActive returns the NumCurrenciesActive field value if set, zero value otherwise.
func (o *InlineResponse2003) GetNumCurrenciesActive() string {
	if o == nil || o.NumCurrenciesActive == nil {
		var ret string
		return ret
	}
	return *o.NumCurrenciesActive
}

// GetNumCurrenciesActiveOk returns a tuple with the NumCurrenciesActive field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetNumCurrenciesActiveOk() (*string, bool) {
	if o == nil || o.NumCurrenciesActive == nil {
		return nil, false
	}
	return o.NumCurrenciesActive, true
}

// HasNumCurrenciesActive returns a boolean if a field has been set.
func (o *InlineResponse2003) HasNumCurrenciesActive() bool {
	if o != nil && o.NumCurrenciesActive != nil {
		return true
	}

	return false
}

// SetNumCurrenciesActive gets a reference to the given string and assigns it to the NumCurrenciesActive field.
func (o *InlineResponse2003) SetNumCurrenciesActive(v string) {
	o.NumCurrenciesActive = &v
}

// GetNumCurrenciesInative returns the NumCurrenciesInative field value if set, zero value otherwise.
func (o *InlineResponse2003) GetNumCurrenciesInative() string {
	if o == nil || o.NumCurrenciesInative == nil {
		var ret string
		return ret
	}
	return *o.NumCurrenciesInative
}

// GetNumCurrenciesInativeOk returns a tuple with the NumCurrenciesInative field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetNumCurrenciesInativeOk() (*string, bool) {
	if o == nil || o.NumCurrenciesInative == nil {
		return nil, false
	}
	return o.NumCurrenciesInative, true
}

// HasNumCurrenciesInative returns a boolean if a field has been set.
func (o *InlineResponse2003) HasNumCurrenciesInative() bool {
	if o != nil && o.NumCurrenciesInative != nil {
		return true
	}

	return false
}

// SetNumCurrenciesInative gets a reference to the given string and assigns it to the NumCurrenciesInative field.
func (o *InlineResponse2003) SetNumCurrenciesInative(v string) {
	o.NumCurrenciesInative = &v
}

// GetNumCurrenciesDead returns the NumCurrenciesDead field value if set, zero value otherwise.
func (o *InlineResponse2003) GetNumCurrenciesDead() string {
	if o == nil || o.NumCurrenciesDead == nil {
		var ret string
		return ret
	}
	return *o.NumCurrenciesDead
}

// GetNumCurrenciesDeadOk returns a tuple with the NumCurrenciesDead field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetNumCurrenciesDeadOk() (*string, bool) {
	if o == nil || o.NumCurrenciesDead == nil {
		return nil, false
	}
	return o.NumCurrenciesDead, true
}

// HasNumCurrenciesDead returns a boolean if a field has been set.
func (o *InlineResponse2003) HasNumCurrenciesDead() bool {
	if o != nil && o.NumCurrenciesDead != nil {
		return true
	}

	return false
}

// SetNumCurrenciesDead gets a reference to the given string and assigns it to the NumCurrenciesDead field.
func (o *InlineResponse2003) SetNumCurrenciesDead(v string) {
	o.NumCurrenciesDead = &v
}

// GetNumCurrenciesNew returns the NumCurrenciesNew field value if set, zero value otherwise.
func (o *InlineResponse2003) GetNumCurrenciesNew() string {
	if o == nil || o.NumCurrenciesNew == nil {
		var ret string
		return ret
	}
	return *o.NumCurrenciesNew
}

// GetNumCurrenciesNewOk returns a tuple with the NumCurrenciesNew field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetNumCurrenciesNewOk() (*string, bool) {
	if o == nil || o.NumCurrenciesNew == nil {
		return nil, false
	}
	return o.NumCurrenciesNew, true
}

// HasNumCurrenciesNew returns a boolean if a field has been set.
func (o *InlineResponse2003) HasNumCurrenciesNew() bool {
	if o != nil && o.NumCurrenciesNew != nil {
		return true
	}

	return false
}

// SetNumCurrenciesNew gets a reference to the given string and assigns it to the NumCurrenciesNew field.
func (o *InlineResponse2003) SetNumCurrenciesNew(v string) {
	o.NumCurrenciesNew = &v
}

// GetMarketCap returns the MarketCap field value if set, zero value otherwise.
func (o *InlineResponse2003) GetMarketCap() string {
	if o == nil || o.MarketCap == nil {
		var ret string
		return ret
	}
	return *o.MarketCap
}

// GetMarketCapOk returns a tuple with the MarketCap field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetMarketCapOk() (*string, bool) {
	if o == nil || o.MarketCap == nil {
		return nil, false
	}
	return o.MarketCap, true
}

// HasMarketCap returns a boolean if a field has been set.
func (o *InlineResponse2003) HasMarketCap() bool {
	if o != nil && o.MarketCap != nil {
		return true
	}

	return false
}

// SetMarketCap gets a reference to the given string and assigns it to the MarketCap field.
func (o *InlineResponse2003) SetMarketCap(v string) {
	o.MarketCap = &v
}

// GetTransparentMarketCap returns the TransparentMarketCap field value if set, zero value otherwise.
func (o *InlineResponse2003) GetTransparentMarketCap() string {
	if o == nil || o.TransparentMarketCap == nil {
		var ret string
		return ret
	}
	return *o.TransparentMarketCap
}

// GetTransparentMarketCapOk returns a tuple with the TransparentMarketCap field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetTransparentMarketCapOk() (*string, bool) {
	if o == nil || o.TransparentMarketCap == nil {
		return nil, false
	}
	return o.TransparentMarketCap, true
}

// HasTransparentMarketCap returns a boolean if a field has been set.
func (o *InlineResponse2003) HasTransparentMarketCap() bool {
	if o != nil && o.TransparentMarketCap != nil {
		return true
	}

	return false
}

// SetTransparentMarketCap gets a reference to the given string and assigns it to the TransparentMarketCap field.
func (o *InlineResponse2003) SetTransparentMarketCap(v string) {
	o.TransparentMarketCap = &v
}

// GetVar1d returns the Var1d field value if set, zero value otherwise.
func (o *InlineResponse2003) GetVar1d() GlobalTickerInterval {
	if o == nil || o.Var1d == nil {
		var ret GlobalTickerInterval
		return ret
	}
	return *o.Var1d
}

// GetVar1dOk returns a tuple with the Var1d field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetVar1dOk() (*GlobalTickerInterval, bool) {
	if o == nil || o.Var1d == nil {
		return nil, false
	}
	return o.Var1d, true
}

// HasVar1d returns a boolean if a field has been set.
func (o *InlineResponse2003) HasVar1d() bool {
	if o != nil && o.Var1d != nil {
		return true
	}

	return false
}

// SetVar1d gets a reference to the given GlobalTickerInterval and assigns it to the Var1d field.
func (o *InlineResponse2003) SetVar1d(v GlobalTickerInterval) {
	o.Var1d = &v
}

// GetVar7d returns the Var7d field value if set, zero value otherwise.
func (o *InlineResponse2003) GetVar7d() GlobalTickerInterval {
	if o == nil || o.Var7d == nil {
		var ret GlobalTickerInterval
		return ret
	}
	return *o.Var7d
}

// GetVar7dOk returns a tuple with the Var7d field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetVar7dOk() (*GlobalTickerInterval, bool) {
	if o == nil || o.Var7d == nil {
		return nil, false
	}
	return o.Var7d, true
}

// HasVar7d returns a boolean if a field has been set.
func (o *InlineResponse2003) HasVar7d() bool {
	if o != nil && o.Var7d != nil {
		return true
	}

	return false
}

// SetVar7d gets a reference to the given GlobalTickerInterval and assigns it to the Var7d field.
func (o *InlineResponse2003) SetVar7d(v GlobalTickerInterval) {
	o.Var7d = &v
}

// GetVar30d returns the Var30d field value if set, zero value otherwise.
func (o *InlineResponse2003) GetVar30d() GlobalTickerInterval {
	if o == nil || o.Var30d == nil {
		var ret GlobalTickerInterval
		return ret
	}
	return *o.Var30d
}

// GetVar30dOk returns a tuple with the Var30d field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetVar30dOk() (*GlobalTickerInterval, bool) {
	if o == nil || o.Var30d == nil {
		return nil, false
	}
	return o.Var30d, true
}

// HasVar30d returns a boolean if a field has been set.
func (o *InlineResponse2003) HasVar30d() bool {
	if o != nil && o.Var30d != nil {
		return true
	}

	return false
}

// SetVar30d gets a reference to the given GlobalTickerInterval and assigns it to the Var30d field.
func (o *InlineResponse2003) SetVar30d(v GlobalTickerInterval) {
	o.Var30d = &v
}

// GetVar365d returns the Var365d field value if set, zero value otherwise.
func (o *InlineResponse2003) GetVar365d() GlobalTickerInterval {
	if o == nil || o.Var365d == nil {
		var ret GlobalTickerInterval
		return ret
	}
	return *o.Var365d
}

// GetVar365dOk returns a tuple with the Var365d field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetVar365dOk() (*GlobalTickerInterval, bool) {
	if o == nil || o.Var365d == nil {
		return nil, false
	}
	return o.Var365d, true
}

// HasVar365d returns a boolean if a field has been set.
func (o *InlineResponse2003) HasVar365d() bool {
	if o != nil && o.Var365d != nil {
		return true
	}

	return false
}

// SetVar365d gets a reference to the given GlobalTickerInterval and assigns it to the Var365d field.
func (o *InlineResponse2003) SetVar365d(v GlobalTickerInterval) {
	o.Var365d = &v
}

// GetYtd returns the Ytd field value if set, zero value otherwise.
func (o *InlineResponse2003) GetYtd() GlobalTickerInterval {
	if o == nil || o.Ytd == nil {
		var ret GlobalTickerInterval
		return ret
	}
	return *o.Ytd
}

// GetYtdOk returns a tuple with the Ytd field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *InlineResponse2003) GetYtdOk() (*GlobalTickerInterval, bool) {
	if o == nil || o.Ytd == nil {
		return nil, false
	}
	return o.Ytd, true
}

// HasYtd returns a boolean if a field has been set.
func (o *InlineResponse2003) HasYtd() bool {
	if o != nil && o.Ytd != nil {
		return true
	}

	return false
}

// SetYtd gets a reference to the given GlobalTickerInterval and assigns it to the Ytd field.
func (o *InlineResponse2003) SetYtd(v GlobalTickerInterval) {
	o.Ytd = &v
}

func (o InlineResponse2003) MarshalJSON() ([]byte, error) {
	toSerialize := map[string]interface{}{}
	if o.NumCurrencies != nil {
		toSerialize["num_currencies"] = o.NumCurrencies
	}
	if o.NumCurrenciesActive != nil {
		toSerialize["num_currencies_active"] = o.NumCurrenciesActive
	}
	if o.NumCurrenciesInative != nil {
		toSerialize["num_currencies_inative"] = o.NumCurrenciesInative
	}
	if o.NumCurrenciesDead != nil {
		toSerialize["num_currencies_dead"] = o.NumCurrenciesDead
	}
	if o.NumCurrenciesNew != nil {
		toSerialize["num_currencies_new"] = o.NumCurrenciesNew
	}
	if o.MarketCap != nil {
		toSerialize["market_cap"] = o.MarketCap
	}
	if o.TransparentMarketCap != nil {
		toSerialize["transparent_market_cap"] = o.TransparentMarketCap
	}
	if o.Var1d != nil {
		toSerialize["1d"] = o.Var1d
	}
	if o.Var7d != nil {
		toSerialize["7d"] = o.Var7d
	}
	if o.Var30d != nil {
		toSerialize["30d"] = o.Var30d
	}
	if o.Var365d != nil {
		toSerialize["365d"] = o.Var365d
	}
	if o.Ytd != nil {
		toSerialize["ytd"] = o.Ytd
	}
	return json.Marshal(toSerialize)
}

type NullableInlineResponse2003 struct {
	value *InlineResponse2003
	isSet bool
}

func (v NullableInlineResponse2003) Get() *InlineResponse2003 {
	return v.value
}

func (v *NullableInlineResponse2003) Set(val *InlineResponse2003) {
	v.value = val
	v.isSet = true
}

func (v NullableInlineResponse2003) IsSet() bool {
	return v.isSet
}

func (v *NullableInlineResponse2003) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableInlineResponse2003(val *InlineResponse2003) *NullableInlineResponse2003 {
	return &NullableInlineResponse2003{value: val, isSet: true}
}

func (v NullableInlineResponse2003) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableInlineResponse2003) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
